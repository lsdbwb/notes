# 概述
- linux使用**Berkeley套接字**接口进行网络编程，这套接口是事实上的标准网络编程套接字接口。Berkeley套接字接口提供了一系列用于网络编程的通用API，通过这些API可以实现跨主机之间网络通信，或是在本机上通过Unix域套接字进行进程间通信
- 几乎所有的（Berkeley）套接字接口都需要传入一个地址参数（比如在connect或send时指定对端的地址），用于表示网络中的一台主机的通信地址。不同的协议类型对应的地址类型不一样，比如IPv4协议对应IPv4地址，长度是32位，而IPv6协议对应IPv6地址，长度是128位，又比如Unix域套接字地址是一个路径字符串
- 因为有多种类型的协议和地址，如果针对每种协议和地址都设置一套接口，那么接口将会特别庞大，不利于使用和维护，因此希望只用一套通用的API接口就完成所有类型的地址的操作

# 通用套接字地址
所有的套接字api都使用**sockaddr的指针**来使用套接字地址，并且需要一个额外的**地址长度**参数
## sockaddr
```c++   
struct sockaddr {
	  sa_family_t sin_family;//地址族
  　　 char sa_data[14]; //14字节，包含套接字中的目标地址和端口信息   
 };
```

除了sockaddr，还定义的一系列的具体网络地址结构
![[Pasted image 20220519164335.png]]

在使用时，所有类型的地址都会转换成**sockaddr指针**形式，又由于以上所有的地址结构的前两个字节都表示地址族，所以**通过sockaddr指针总能拿到传入地址的地址类型**，通过地址类型判断出地址长度后，再通过sockaddr指针取适合该地址的长度即可拿到地址内容。

## 使用的例子
使用时，都是先定义网络地址结构，然后转成sockaddr* 形式传入套接字api，同时要传入网络地址结构的长度

![[Pasted image 20220519164609.png]]