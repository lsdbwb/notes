# 系统调用的概念
系统调用是计算机程序在运行过程中向操作系统内核*申请服务的方法*。
系统调用为用户程序提供了操作系统的接口

![[Pasted image 20220706144139.png]]

**为什么需要系统调用：**
应用程序能做的事情有限，很多都依赖于操作系统提供的服务

# 系统调用和函数调用的开销
函数调用的大致过程：
1. 分配新的栈空间
2. 传递参数到寄存器
3. 执行CALL指令跳转到目标地址执行函数
4. 执行完毕后函数返回时通过栈或者寄存器传递返回值

系统调用相比于函数调用的开销大得多，因为系统调用开始需要从用户态切换到内核态，需要拷贝参数到内核态，系统调用结束后还需要从内核态返回用户态。

通常一个系统调用消耗的时间是C函数调用的几十倍

# linux执行系统调用的三种方法
![[Pasted image 20220706144919.png]]

## 软件中断
**中断的概念：**
中断是向处理器发送的输入信号，它能够表示某个时间需要操作系统立即处理。如果操作系统接收了中断信号，那么处理器就会暂停当前任务，保存当前上下文并且切换到中断处理程序进行执行，中断处理完成后再重新恢复上下文并继续之前的工作。

**中断分为硬件中断和软件中断：**
- 硬件中断：处理器外部的设备向处理器发出的*电子信号*
- 软件中断(soft interrupt) ：程序执行特定指令时触发的（比如除以0的异常指令），某些特殊的指令也可以用来故意触发中断

在32位的x86系统上，可以使用*INT指令*来触发软件中断。早期的 Linux 会使用 `INT 0x80` 触发软件中断、注册特定的中断处理器 [`entry_INT80_32`](https://github.com/torvalds/linux/blob/458ef2a25e0cbdc216012aa2b9cf549d64133b08/arch/x86/entry/entry_32.S#L1072) 来处理系统调用

**软件中断执行系统调用的过程**

1. 应用程序通过C语言库中的函数发起系统调用
2. C语言函数通过栈收到应用传来的系统调用需要的参数并拷贝到寄存器中
3. Linux的每一个系统调用都有*特定的序号*，函数会将系统调用的序号拷贝到eax寄存器
4. 函数执行INT 0x80指令，处理器会**从用户态转换为内核态**并执行预先定义好的中断处理器
5. 执行中断处理器 [`entry_INT80_32`](https://github.com/torvalds/linux/blob/458ef2a25e0cbdc216012aa2b9cf549d64133b08/arch/x86/entry/entry_32.S#L1072) 处理系统调用；
	1. 执行`SAVE_ALL`将寄存器的值存储到内核栈上并调用`do_int80_syscall_32`；
	2. 调用 [`do_syscall_32_irqs_on`](https://github.com/torvalds/linux/blob/458ef2a25e0cbdc216012aa2b9cf549d64133b08/arch/x86/entry/common.c#L315) 检查系统调用的*序号是否合法*；
	3. 在系统调用表`ia32_sys_call_table`中查找对应的系统调用实现并传入寄存器的值。
	4. 系统调用在执行过程中会检查参数的合法性、在用户态和内核态之间传输数据，系统调用的结果会被存到`eax`寄存器中
	5. 从内核栈中恢复寄存器的值并将返回值放到栈上，*切换回用户态*。
	6. 系统调用会返回 C 函数，包装函数会将结果返回给应用程序；
6. 如果系统调用服务在执行过程中出现了错误，C 语言函数会将错误存储在全局变量 `errno` 中并根据系统调用的结果返回一个用整数 `int` 表示的状态；

由上可见软件中断执行系统调用是一个很复杂的过程，主要包括用户态和内核态的切换，用户态和内核态传输参数，查询系统调用表，还要验证参数合法性。与函数调用的过程相比确实会带来很多额外的开销。


*实际上，使用 `INT 0x80` 来触发系统调用早就是过去时了，大多数的程序都会尽量避免这种触发方式*

## SYSCALL指令
![[Pasted image 20220706151853.png]]
使用以上几个快速系统调用和返回指令进行系统调用比使用软件中断的方式更快（可以减少25%的时钟周期）。它们会认为操作系统实现了线性内存模型（Linear-memory Model），极大地简化了操作系统系统调用和返回的过程，其中包括不必要的检查、预加载参数


**在 64 位的操作系统上，我们会使用 `SYSCALL` / `SYSRET` 进入和退出系统调用，该指令会在操作系统最高权限等级中执行**
1. 内核在初始化时会调用syscall_init函数将`entry_SYSCALL_64`存入MSR寄存器中（Model Specific Register、MSR，MSR 寄存器是 x86 指令集中用于调试、追踪以及性能监控的控制寄存器）
2. 当内核收到了用户程序触发的系统调用时，它会在MSR寄存器中读取需要执行的函数（即`entry_SYSCALL_64`）并按照 x86-64 的调用惯例*在寄存器中读取系统调用的编号以及参数*
3. 汇编函数 [`entry_SYSCALL_64`](https://github.com/torvalds/linux/blob/c14cab2688d09b851349acbb83e5fce8e0d4ca42/arch/x86/entry/entry_64.S#L145) 会在执行的过程中调用 `do_syscall_64`
,其会在**系统调用表**中查找系统调用的函数并传入寄存器中的参数（系统调用需要的）

与 `INT 0x80` 通过触发软件中断实现系统调用不同，`SYSENTER` 和 `SYSCALL` 是专门为系统调用设计的汇编指令，它们不需要在中断描述表（Interrupt Descriptor Table、IDT）中查找系统调用对应的执行过程，也**不需要保存堆栈和返回地址**等信息，所以能够减少所需要的额外开销。

## vDSO
vDSO(virtual Dynamic Shared Object)：虚拟动态共享对象
是linux内核对用户空间暴露内核态部分函数的机制

简单来说，我们将 Linux 内核中*不涉及安全的系统调用直接映射到用户空间*，这样用户空间中的应用程序在调用这些函数时就*不需要切换到内核态*以减少性能上的损失。


**vDSO的实现：**
vDSO使用了标准的链接和加载技术，作为一个动态链接库，由*linux内核提供并映射到每一个正在执行的进程上*。

如下所示，linux的cat程序里加载了linux-vdso.so.1
![[Pasted image 20220706155438.png]]
如下所示，vDSO被映射到了进程的地址空间
![[Pasted image 20220706155537.png]]

vDSO是由操作系统内核直接提供的，因此并不存在对应的文件。vDSO可以为用户程序提供虚拟的系统调用，它会使用内核提供的数据在用户态模拟系统调用

**vDSO初始化的过程**：
![[Pasted image 20220706155952.png]]
1.  内核中的 ELF 加载器会负责映射 vDSO 的内存页并设置辅助向量（Auxiliary Vector）中 `AT_SYSINFO_EHDR`，该标签存储了 vDSO 的基地址；
2.  动态链接器会查询辅助向量中 `AT_SYSINFO_EHDR`，如果设置了该标签会链接 vDSO；
3.  libc 在初始化时会在 vDSO 中查找 `__vdso_gettimeofday` 符号并将符号链接到全局的函数指针上；


除了 `gettimeofday` 之外，多数架构上的 vDSO 还包含 `clock_gettime`、`clock_getres` 和 `rt_sigreturn`（通常该函数的功能就是直接返回-1并设置errno） 等三个系统调用，这些系统调用完成功能相对来说比较简单，也不会带来安全上的问题，所以将它们映射到用户空间可以明显地提高系统调用的性能