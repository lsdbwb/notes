# 概念
- 在打开文件创建文件描述符fd时加上O_CLOEXEC标识，在使用fork创建子进程后，使用exec执行子进程时，fd会自动关闭
- 对于socket，则是加上SOCK_CLOEXEC标志

# 不使用close-on-exec可能导致的问题
## 出现问题的原因
在父进程fork子进程时，由于写时复制(copy-on-write)机制，子进程会获得父进程的数据空间，堆，栈的副本，其中也包括文件描述符，父子进程的文件描述符指向系统文件表的同一表项。在子进程exec时会使用自己的程序的上下文，数据，堆栈等替换父进程的，此时保存文件描述符的变量就不存在了，因此就无法去关闭无用的文件描述符了
## 解决的方法
1. 在exec前手动去关闭父进程打开的所有的文件描述符（复杂的系统打开的描述符太多了，容易遗漏）
2. 在创建文件描述符时加上close-on-exec选项