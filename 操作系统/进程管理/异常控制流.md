# 异常控制流概念
异常控制流(Exception Control Flow,ECF)

CPU一段时间执行的指令序列被称为控制流，执行下一条指令被称为控制流的转移

CPU不停地根据程序计数器存放的指令的地址取指令执行，通常CPU都是按顺序执行代码段中的指令（称为控制流的平滑转移），使用*跳转、调用和返回*等指令可以让CPU去执行指定位置的指令（称为控制流突变）。这些指令是必要的机制，使得程序能够对由*程序变量表示的内部程序的状态*中的变化作出反应

系统必须能够对*系统的状态变化*做出反应，这些系统状态不是由内部程序变量捕获的，而且也不一定和程序的执行状态相关

系统状态变化的例子：
- 硬件定时器定期产生信号，CPU必须进行处理
- 包到达网络适配器后，必须放到内存
- 磁盘IO事件完成后，CPU要进行处理
- 父进程创建的子进程结束后，需要通知父进程

现代系统通过使得控制流发生突变来对以上系统状态的变化做出反应，这些突变就被称为**异常控制流**。简单来说就是CPU暂停执行原来的指令序列，转去执行其他的子例程，这些子例程要对以上系统变化作出相应的处理，处理完成后再恢复原来的执行

异常控制流发生在系统的各个层次：
- 硬件层：硬件检测到的事件会触发CPU转移到异常处理程序
- 操作系统层：内核通过上下文切换将一个用户进程切换到另外一个用户进程执行
- 应用层：一个进程可以向另一个进程发送*信号*，信号接收者就会将控制转移到其信号处理程序；一个程序可以通过回避通常的栈规则，并执行到其他函数中的任意位置的*非本地跳转*来对错误作出反应

# 异常
异常是异常控制流的一种形式，它的一部分由硬件实现，一部分由操作系统实现。

异常就是控制流的突变，用来反映处理器状态的变化

![[Pasted image 20220615154258.png]]

**事件的定义**
事件即状态变化
事件可能和当前指令的执行直接相关：比如虚拟内存缺页，除0错误，算术溢出等
事件也可能和当前指令的执行无关：定时器超时发出信号或者IO请求完成

**检测到事件发生时的处理**：
任何时候，当处理器检测到事件发生时，就会暂停当前指令的执行。通过查找一张叫*异常表（exception table)* 的跳转表，进行一个间接过程调用，跳转到操作系统提供的*异常处理程序(exception handler)* 中去 

当异常处理程序完成处理后，根据引起异常的事件类型，会产生以下几种情况：
1. 返回事件发生时的那条指令Icurr继续执行
2. 返回事件发生时的那条指令的下一条指令Inext继续执行
3. 终止程序

## 异常处理
### 异常表的结构
异常表是进行异常处理必须的数据结构：每一个表项的位置代表异常号，表项存放的是该异常号对应的异常处理程序代码的地址

异常表在操作系统每次启动时进行分配和初始化
![[Pasted image 20220615155355.png]]

### 异常号
系统为每种可能的异常都分配了一个唯一的非负整数的*异常号*（exception number）
由处理器设计者分配的异常号：
- 被0除
- 缺页
- 内存访问违例
- 断点（gdb调试）
- 算术运算溢出
- 。。。

由操作系统分配的异常号：
- 系统调用
- 来自外部的IO信号
- 。。。

### 异常处理的过程
如下图所示，异常表的首地址存放在异常表基址寄存器中
![[Pasted image 20220615160054.png]]
1. 处理器检测到异常事件发生
2. 根据事件的类型确定相应的异常号k
3. 根据异常号作为索引去异常表查找对应的异常处理程序的地址
4. 设置PC计数器，跳转到异常处理程序开始执行
5. 异常处理程序结束后，通过一条特殊的“从中断返回”指令，可选地返回到被中断的程序。该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用户模式， 然后将控制返回给被中断的程序

### 异常处理的特点
异常处理和过程调用有相似之处，但也有所不同
1. 过程调用中，在跳转到处理程序之前，处理器将返回地址压入栈中。在异常处理中，返回地址要么是当事件发生时正在执行的指令，要么是事件发生时的下一条指令
2. 处理器也会在异常处理之前把一些处理器状态存到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态
3. 如果控制从用户态转移到内核态，那么上述状态都会被存放在*内核栈*而不是用户栈中
4. 异常处理程序运行在内核模式下，这意味着它对所有的系统资源都有完全的访问权限


### 异常的类别
根据产生的原因、是同步还是异步操作以及返回行为来划分异常
![[Pasted image 20220615161344.png]]
#### 中断
中断是异步发生的，是来自*处理器外部*的IO设备的信号的结果。硬件中断不是任何一条指令造成的。硬件中断的异常处理程序常常称为中断处理程序（interrupt handler)

![[Pasted image 20220615163833.png]]
中断的过程
1. 通过向处理器芯片的一个引脚发信号，并将异常号放到系统总线上来触发中断（异常号标识了触发中断的设备）
2. 在当前指令完成后，处理器注意到引脚的电压变高了，就从系统总线读取异常号，然后调用中断处理程序
3. 中断处理程序执行完毕后，就返回到原来的程序的下一条指令继续执行

#### 陷阱和系统调用
陷阱是有意的异常，是执行一条指令的结果。和中断一样，陷阱处理程序执行完后也返回到原来程序的下一条指令继续执行。

陷阱最重要的作用是在*用户程序和内核之间*提供像过程调用一样的接口，叫做系统调用

**陷阱的处理流程**：
处理器提供一条特殊的指令"syscall n"来陷入陷阱
![[Pasted image 20220615164643.png]]

**普通函数和系统调用的区别**：
普通函数运行在用户模式下
系统调用运行在内核模式下，可以执行特权指令，有所有系统资源的完全访问权限


#### 故障
故障由错误情况引起，它可能能够被故障处理程序修正

如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的abort 例程，abort 例程会终止引起故障的应用程序

![[Pasted image 20220615165044.png]]

#### 终止
终止通常是出现了致命的不可恢复的错误，通常是硬件错误
终止处理程序会调用abort终止这个应用程序
![[Pasted image 20220615165212.png]]

