# 动态内存分配
- 可以使用mmap和munmap来创建和删除虚拟内存的区域，但使用和维护起来不方便
- 当需要额外的虚拟内存时，使用*动态内存分配器*更加地方便，也有更好的移植性

动态内存分配器用来管理进程虚拟内存空间的堆区
![[Pasted image 20220612112038.png]]
## 堆区的特点
1. 堆是请求二进制0的区域（映射的是匿名文件）
2. 堆区紧跟在.bss段
3. 堆区从低地址向高地址增长
4. 每个进程都维护一个brk的变量，指向堆区的*堆顶*
5. 可以使用mmap或者sbrk系统调用[[内存相关api]]来显示地映射堆区内存，增大堆区的大小

## 动态内存分配器如何管理堆区
动态分配器管理的是当前可用的堆区（已经进行虚拟内存映射的），即从.bss段到brk指针这个区域的虚拟内存

1. 动态内存分配器将堆区视作一系列大小不同的块（block）的集合来维护
2. 块分为两种，一种是已分配的块，一种是空闲块。已分配的块显式地保留给应用程序使用，空闲块可以被分配。一个已分配的块保持已分配的状态，直到被释放

## 分配器的分类
分配器都需要显式地分配内存块，但是释放已分配内存块可以有两种方式，根据*谁来释放已分配的内存块*的不同，可以分为以下两种类型的分配器

**显式分配器**
应用程序必须负责显式地释放任何已分配的内存
例如c标准库的malloc/free和c++的new/delete操作符

**隐式分配器**
要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器（garbage collector), 而自动释放未使用的已分配的块的过程叫做垃级收集（garbage collection)
例如java等高级语言


# 显式分配器的设计
C 标准库提供了一个称为malloc 程序包的显式分配器。程序通过调用malloc 函数来从堆区中分配块。
## malloc程序包
- malloc
malloc 函数返回一个指针，指向大小为至少size 字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型*做对齐*（64位下返回的内存块的地址总是16的整数倍）
```c++
#include <stdlib.h>
void *malloc(size_t size);
```
返回的内存块*没有做任何初始化*
如果size=0，则malloc要么返回NULL，要么返回一个能被free正常处理的特殊地址

- calloc
为大小为nmemb的数组（每个对象的大小为size）分配足够大小的内存块，内存块*会被置0*
```c++
void *calloc(size_t nmemb, size_t size);
```

- realloc
改变ptr指示的已经分配的内存块的大小
```c++
 void *realloc(void *ptr, size_t size);
```
如果size小于原来的大小：则还剩下的内存块的内容没有改变
如果size大于原来的大小：则新分配的部分是未被初始化的

- reallocarray
和realloc一样，只是内存块的大小由(数组大小nmemb * 数组内对象大小size）指示
```c++
void *reallocarray(void *ptr, size_t nmemb, size_t size);
```

- free
释放ptr指向的由以上函数分配的内存块
```c++
void free(void *ptr);
```
ptr 参数必须指向一个从mallocÿ calloc 或者realloc 获得的已分配块的起始位置。如果不是，那么free 的行为就是未定义的

如果ptr为NULL，则不做任何操作

## 为什么需要动态内存分配器
有时直到程序实际运行时，才知道某些数据结构的大小

## 动态内存分配器的要求和目标
**约束条件**
1. 处理任意请求序列
	一个应用可以有任意的分配请求和释放请求的序列，只要满足以下约束条件
	- 每个释放请求必须对应于一个当前已经分配的块，这个块是早先使用分配器分配的
	- 分配器不能假定分配和释放请求的顺序

2. 立即响应请求
	分配器必须立即响应分配请求。不允许分配器为了提升性能重新排列或者缓冲请求

3. 只使用堆
	为了使得分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里

4. 内存对齐
	分配器必须对齐块，使得它们可以保存任何类型的数据对象

5. 不修改已经分配的块
	分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。

**目标**
在以上约束条件下，分配器要在最大化吞吐率和最大化内存使用率上综合考量，因为这两个目标往往是冲突的
1. 最大化吞吐率
	- 吞吐率定义为每个单位时间里完成的请求数
	- 一般而言，我们可以通过使满足分配和释放请求的平均时间最小化来使吞吐率最大化
	
2. 最大化内存使用率
	虚拟内存并不是一个无限的资源，事实上，一个系统中，被所有进程分配的虚拟内存的全部数量是受*磁盘上交换空间的容量*限制的

通常使用*峰值利用率*来描述一个分配器的效率：
![[Pasted image 20220613143334.png]]


## 考虑内存碎片问题
还有未使用的内存，但是无法用来满足分配请求
### 内部碎片
内部碎片是在一个块的内部产生的

**产生原因**
1. 分配器是以块为单位分配和释放内存，分配器规定了一个块(block)有最小值，而应用程序申请的内存大小仍然小于这个最小值
2. 分配器因为内存对齐的要求，分配的块会有没有用上的填充空间

**计算方法**
已分配的块的大小和其有效载荷之间的差值

内部碎片的数量只取决于*以前应用的请求模式*和*分配器的实现方式*

### 外部碎片
外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的

外部碎片不仅取决于*以前应用的请求模式*和*分配器的实现方式*，还取决于未来应用的请求模式

外部碎片难以预测和量化，因此分配器都会使用启发式的策略来试图维持少量的大内存块，而不是大量的小内存块（大内存块能满足更多应用的要求）

## 实现分配器需要注意的问题
一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题

1. 如何组织和管理空闲块
2. 放置：如何从空闲块中选择一个合适的块进行分配
3. 分割：将一个新分配的块放置到某个空闲块后，如何处理该空闲块剩下的部分
4. 合并：如何处理一个刚刚释放的块

### 使用隐式空闲链表组织空闲块
需要区分块的边界
需要区分已分配块和空闲块
大部分的分配器将这些信息嵌入块本身

如下是一个简单的堆块格式：
![[Pasted image 20220613145518.png]]
分为三部分：
1. 头部 ： 包括块大小和是否是空闲块的信息
2. 有效载荷 ： 实际可以供应用使用的内存
3. 填充：可能是分配器策略的一部分，用来对付外部碎片；另外就是做内存对齐

使用隐式空闲链表组织堆：
![[Pasted image 20220613150109.png]]



