# 动态内存分配
- 可以使用mmap和munmap来创建和删除虚拟内存的区域，但使用和维护起来不方便
- 当需要额外的虚拟内存时，使用*动态内存分配器*更加地方便，也有更好的移植性

动态内存分配器用来管理进程虚拟内存空间的堆区
![[Pasted image 20220612112038.png]]
## 堆区的特点
1. 堆是请求二进制0的区域（映射的是匿名文件）
2. 堆区紧跟在.bss段
3. 堆区从低地址向高地址增长
4. 每个进程都维护一个brk的变量，指向堆区的*堆顶*
5. 可以使用mmap或者sbrk系统调用[[内存相关api]]来显示地映射堆区内存，增大堆区的大小

## 动态内存分配器如何管理堆区
动态分配器管理的是当前可用的堆区（已经进行虚拟内存映射的），即从.bss段到brk指针这个区域的虚拟内存

1. 动态内存分配器将堆区视作一系列大小不同的块（block）的集合来维护
2. 块分为两种，一种是已分配的块，一种是空闲块。已分配的块显式地保留给应用程序使用，空闲块可以被分配。一个已分配的块保持已分配的状态，直到被释放

## 分配器的分类
分配器都需要显式地分配内存块，但是释放已分配内存块可以有两种方式，根据*谁来释放已分配的内存块*的不同，可以分为以下两种类型的分配器

**显式分配器**
应用程序必须负责显式地释放任何已分配的内存
例如c标准库的malloc/free和c++的new/delete操作符

**隐式分配器**
要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器（garbage collector), 而自动释放未使用的已分配的块的过程叫做垃级收集（garbage collection)
例如java等高级语言


# 显式分配器的设计
C 标准库提供了一个称为malloc 程序包的显式分配器。程序通过调用malloc 函数来从堆区中分配块。
## malloc程序包
- malloc
malloc 函数返回一个指针，指向大小为至少size 字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型*做对齐*（64位下返回的内存块的地址总是16的整数倍）
```c++
#include <stdlib.h>
void *malloc(size_t size);
```
返回的内存块*没有做任何初始化*
如果size=0，则malloc要么返回NULL，要么返回一个能被free正常处理的特殊地址

- calloc
为大小为nmemb的数组（每个对象的大小为size）分配足够大小的内存块，内存块*会被置0*
```c++
void *calloc(size_t nmemb, size_t size);
```

- realloc
改变ptr指示的已经分配的内存块的大小
```c++
 void *realloc(void *ptr, size_t size);
```
如果size小于原来的大小：则还剩下的内存块的内容没有改变
如果size大于原来的大小：则新分配的部分是未被初始化的

- reallocarray
和realloc一样，只是内存块的大小由(数组大小nmemb * 数组内对象大小size）指示
```c++
void *reallocarray(void *ptr, size_t nmemb, size_t size);
```

- free
释放ptr指向的由以上函数分配的内存块
```c++
void free(void *ptr);
```
ptr 参数必须指向一个从mallocÿ calloc 或者realloc 获得的已分配块的起始位置。如果不是，那么free 的行为就是未定义的

如果ptr为NULL，则不做任何操作

## 为什么需要动态内存分配器

## 动态内存分配器的要求和目标

