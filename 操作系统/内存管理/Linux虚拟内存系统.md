
虚拟内存只是对主存的一种抽象的概念，数据还是存放在实际的物理内存中的，CPU需要必须知道一个对象的物理地址才可能去访问它。虚拟内存到实际物理内存的映射是由硬件(MMU负责地址翻译)和操作系统（负责管理页表）共同协作完成，这一部分比较底层，平常不为用户所感知，用户把这一部分当作黑盒子就可以。

程序中使用的地址都是虚拟地址，进程也是工作在虚拟内存空间。实际的操作系统需要去设计和管理虚拟内存空间

# linux管理虚拟内存
## linux虚拟内存布局
根据地址空间的概念[[基本概念#地址空间]]，一个进程的虚拟地址空间就是从0到N-1的一系列虚拟地址

下图是linux一个进程的虚拟内存的布局
主要分为两个大的区域：内核虚拟内存区域和进程虚拟内存区域
![[Pasted image 20220611144857.png]]


Linux把一个进程的虚拟内存划分为多个**虚拟内存区域**来管理
![[Pasted image 20220611145321.png]]
1. 每个进程都有自己的task_struct来描述自己的各种信息和状态
2. task_struct的mm字段指向mm_struct，用来描述虚拟内存的当前状态
3. mm_struct里需要关心两个字段：pgd和mmap。pgd指向第一级页表的基址（当内核运行这个进程时，就将pgd放入CR3寄存器中），而mmap 指向一个vm_area_structs(区域结构）的链表,每个vm_area_structs都描述了虚拟地址空间的一个区域
	- vm_start: 指向这个区域的起始处。
	- vm_end: 指向这个区域的结束处。
	- vm_prot: 描述这个区域内包含的所有页的读写许可权限。
	- vm_flags: 描述这个区域内的页面是与其他进程共享的，还是这个进程私有的（还描述了其他一些信息
	- vm_next: 指向链表中下一个区域结构

## linux缺页异常处理
假设MMU 在试图翻译某个虚拟地址A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，缺页处理程序进行处理时会分为以下3种情况
![[Pasted image 20220611151439.png]]
1. *虚拟地址A不合法*，即A没有处于任何一个vm_area_struct中，还没有将A所在的虚拟内存区域纳入管理。此时会触发一个段错误并终止进程
2. 虚拟地址A是合法的，但是试图进行的*内存访问不合法*。例如尝试修改一个只读页面，用户态程序尝试访问内核虚拟内存区域等。此时会触发保护异常，然后中断进程
3. 正常缺页，这个缺页是由于对合法的虚拟地址进行合法的操作造成的。说明物理内存已经满了，需要选择一个牺牲页面，如果这个页面被修改过，那么就需要置换该页面，换入新的页面


# 内存映射
## 概念
内存映射指的是linux把一块虚拟内存区域和一个磁盘上的对象(object)关联起来，以初始化这个虚拟内存区域的内容

## 可以映射两种对象
1. linux文件系统中的普通文件
	一个区域可以映射到一个普通文件的连续部分，例如一个可执行文件
	
	文件区（section）被划分为页大小的片，每一片包含一个虚拟页面的初始内容

	映射时并没有将文件的内容加载到物理内存上，而是在CPU第一次实际用到该页面的内容时（即发射一个虚拟地址，落在这片虚拟地址空间的范围之内）才会加载该页的内容到物理内存

	如果虚拟内存区域比文件区要大，则用0来填充这个区域的剩下部分
	
2. 匿名文件
	一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全部是二进制0

	cpu*第一次引用匿名页*时，内核会分配一个空闲的物理内存页给它，并将该页的内容全部置为0，并将这个页面标记为驻留在内存中

	映射到匿名文件的区域中的页面有时也叫做**请求二进制零的页**（demand-zero page)


无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件（swap file)之间换来换去

交换文件也叫做交换空间（swap space)或者交换区域(swap area)

在任何时刻，**交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数**


## 共享对象和私有对象
一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象

### 共享对象
共享对象是多个进程共享的，某个进程对该对象做了修改，其余进程都能感知到
![[Pasted image 20220611161822.png]]
共享对象在物理内存中只需要存放一份，每个进程都维持各自的虚拟内存区域到该对象的物理内存区域的映射即可

### 私有对象
私有对象是每个进程独有的，该对象在物理内存中有多份拷贝

私有对象是通过**写时复制**的机制进行内存映射的
![[Pasted image 20220611162816.png]]

私有对象开始生命周期的方式基本上与共享对象的一样，在物理内存中只保存有私有对象的一份副本，多个进程都映射到该对象的同一块物理内存上。

如果多个进程对该对象只进行读操作，就可以继续共享物理内存的同一个对象的副本。如果某个进程要对该对现象进行写操作，就会触发一个*保护故障*

当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在*物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本*，然后恢复这个页面的可写权限，如图9-30b 所示。当故障处理程序返回时，CPU 重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了

写时复制技术充分地利用了稀有的物理内存