# 虚拟内存
## 概念
虚拟内存（virtual memory）是对主存的一种抽象概念，它为每个进程提供了大的、一致的和私有的地址空间

## 提供的三个重要能力
1. 把主存当作磁盘的高速缓冲设备，主存里只存放当前进程所需的数据，根据需要在主存和磁盘间交换数据
2. 为每个进程提供了一致的地址空间，简化了内存管理
3. 保证了进程之间的隔离，一个进程的地址空间不被其他进程破坏


# 从两个方面理解虚拟内存
## 虚拟内存作为缓存的工具
从主存作为磁盘的缓存的角度上来看：
1. 主存的存取速度远远大于磁盘的存取速度（磁盘要比DRAM 慢大约100 000 多倍），因此读取磁盘上的数据时，都是先把磁盘上的数据读到内存
2. 主存的空间大小远远小于磁盘空间的大小，因此磁盘上的内容不可能完全加载到主存上去

**虚拟内存为什么要以页为单位**
	虚拟内存的最小单位是页（页的大小通常是4KB~2MB），类似地，物理内存被划分为物理页（页帧）
	这是因为磁盘是一个块设备，从磁盘的一个扇区读取第一个字节的时间开销比起**读这个扇区中连续的字节**要慢大约100 000 倍
	因此内存以页为单位去缓存磁盘的数据，页的大小通常大于等于磁盘IO每次读一块的大小

**虚拟内存在内存作为磁盘缓存时起了什么作用**
还是因为主存的空间远远小于磁盘空间的问题，系统首先并不真正将磁盘上所有数据加载到物理内存，而是建立虚拟内存的页到磁盘上的块的**映射关系**。
![[Pasted image 20220610154541.png]]
如上图所示，在任意时刻，虚拟页面的集合都分为三个不相交的子集：
- 未分配的：VM 系统还未分配(或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。
- 缓存的：当前已缓存在物理内存中的已分配页。
- 未缓存的：未缓存在物理内存中的已分配页。

虚拟内存必须知道上述三种子集的情况，因此需要一个数据结构存放这些信息，这就是页表

### 页表
页表由页表项组成，每个页表项大小固定
在只考虑虚拟内存的缓存功能时，页表项至少有以下内容：
	1. 页表项会存放一个有效位，标志该页是否已经从磁盘加载到了物理内存 
	2. 页表项的有效位后面存放的是物理页号或者磁盘地址（MMU做虚拟地址到物理地址的翻译时要用到）
操作系统要负责维护页表的内容；当物理内存满了，负责页面置换，将物理内存的某页换出到磁盘以及从磁盘中加载新页到物理内存

![[Pasted image 20220610155326.png]]
**页命中的流程**：
	1. MMU作为一个地址翻译单元使用传入的虚拟地址作为索引，从页表中找到页表项（PTE)
	2. 查看PTE的有效位是否为1，如果*为1*，说明页命中了，该页正缓存在物理内存中，然后就使用页表项中存放的物理地址来访问物理页面

**缺页时的流程**：
	在DRAM中缓存不命中即为缺页（page fault）
	1. MMU作为一个地址翻译单元使用传入的虚拟地址作为索引，从页表中找到页表项（PTE)
	2. 查看PTE的有效位是否为1，如果*不为1*，说明该页没有缓存在物理内存中，触发缺页异常并调用缺页异常处理程序
	缺页中断：
	1. 如果物理内存还有空间，则就会根据PTE的磁盘地址，读取磁盘块的内容到物理内存的空闲页中
	2. 如果物理内存没有空间，则要执行页面置换算法，从物理内存中换出一个页（如果物理内存的内容有被修改，则要复制回磁盘），然后将磁盘的对应块换入
	从缺页中断处理程序返回：
		重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重新发送到MMU中，因为该页已经在物理内存中了，接下来就是正常的*页命中*的流程

### 局部性原理使得虚拟页表工作效率很高
- 整个程序运行过程中引用的不同页面的总数可能超过物理内存总的大小
- 局部性原理保证了任意时刻，程序趋向于在一个较小的活动页面（active page)集合上工作，这个集合叫做工作集(working set)
- 程序启动时就将工作集页面调度到内存中，接下来对工作集内存页面的访问将导致命中，不需要从磁盘中去读
- 如果程序的局部性不好，那么很可能频繁地出现页面换入换出的现象（也叫做*抖动*）

## 虚拟内存作为内存管理的工具
操作系统为每个进程都提供了独立的页表，即每个进程都有自己独立的虚拟内存空间
多个虚拟页面可以共享同一个物理页面
![[Pasted image 20220610164541.png]]

## 按需页面调度和独立的虚拟地址空间带来的好处
**简化链接**
	1. 独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不用考虑代码和数据实际放在物理内存的何处
	2. 这样的一致性简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，而不用管每个可执行文件在物理内存上是怎么放的

**简化加载**
	1. 虚拟内存使得容易向内存中加载可执行文件和共享对象
	2. 要把目标文件中.text 和.data 节加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的）， 将页表条目指向*目标文件*中适当的位置
	3. 在每个页被初次引用时，才会真正地将数据页从磁盘调入物理内存
	
**简化共享**

**简化内存分配**
