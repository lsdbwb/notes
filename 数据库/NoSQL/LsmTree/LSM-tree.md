# LSM-Tree的概念
LSM-Tree全称为log-structured merge-tree（结构化合并树）

# LSM-Tree的思想
1. 磁盘顺序写
2. 多个树（状）数据结构，先内存再磁盘
3. 冷热（新老）数据分级存储
4. 定期更新合并
5. 非原地更新

# LSM-Tree的定义
![[Pasted image 20220617102640.png]]
1. LSM树是一颗横跨内存和磁盘，由多颗子树构成的森林
2. LSM-Tree分为Level 0，Level 1，Level 2 ... Level n 多颗子树，其中只有Level 0在内存中，其余Level 1-n在磁盘中
3. 在内存里的Level 0子树是一颗有序平衡树（AVL/红黑树）或者跳表等有序的数据结构，方便后续顺序写入磁盘
4. 磁盘上的Level 1-n虽然也被叫做树，但实质上是数据排好序后按顺序存储在磁盘文件
5. 每一层的子树都有阈值大小，到达阈值后会进行合并（compaction），合并后的结果写入下一层
6. 只有内存中的数据允许原地更新，磁盘上的数据只允许*追加写*，不允许原地更新

# LSM-Tree的操作
## 增加(PUT)
插入操作直接在内存上level 0子树上执行
就是在一颗平衡树上进行插入操作

## 删除(DELETE)
删除操作并不是真正的去删除数据，而是采用一种叫“墓碑标记”的机制去标记一个数据已经被删除了

删除操作都是等价于向Level 0树中写入墓碑标记

## 修改(UPDATE)
如果要修改的数据在内存的level 0树上，则直接去进行修改

如果要修改的数据在磁盘的树上，则不会去磁盘上直接修改，而是把这个修改的数据当作新的数据插入到内存的level 0树上

**LSM-Tree的三个写操作(put、delete、update)都是只在内存的level 0树上进行操作，因此速度很快**

## 查询(GET)
LSM树的查询操作会按顺序查找Level 0、Level 1、Level 2 ... Level n 每一颗树，一旦匹配便返回目标数据，不再继续查询。该策略保证了查到的一定是目标key最新版本的数据

查询在极端情况下可能需要把整个从Level 0 到Level n的子树都扫描一遍，因此性能较差

## 归并(MERGE)
**为什么要进行Merge操作**
1. 内存不是无限大的，因此内存中的数据到达一定容量后要刷到磁盘上保存
2. 对磁盘上到达阈值的文件使用归并操作清除重复的数据和已删除的数据（墓碑标记），缩短读取路径，节省磁盘空间


# 优缺点
优点：插入、删除、更新等写操作都在磁盘上进行，写操作吞吐量极大

缺点：读性能被相对弱化，不擅长区间范围的查询操作；归并操作比较消耗资源

