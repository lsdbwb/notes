# 各种定义
## 阻塞数据结构和算法
（blocking data structures and algorithoms）
- 定义：
	使用mutex，condition variables，future去同步数据
- 特点
	使用以上工具时，会使用阻塞调用。操作系统会将阻塞线程完全挂起，将时间片分给其他线程，直到其他线程完成特定操作(释放锁，notify()，future准备完毕等)唤醒阻塞的线程

## 非阻塞数据结构和算法
- 定义：
不使用阻塞库函数调用来实现线程间数据同步
- 非阻塞并不意味着lock-free
	比如使用std::atomic_flag来实现的自旋锁，线程虽然不会调用阻塞函数，但是会一直循环等待，空占cpu

## lock-free数据结构
- 定义
	1. 多个线程可以同时访问该数据结构，可以做相同的或者不同的操作
	2. 多线程间互不影响：即使某个线程进行了阻塞操作，也不影响其他线程对该数据结构的操作
- 通常会使用CAS操作来实现
	使用CAS可能会造成thread starvation，即另一个线程中途修改了数据结构，导致当前线程不得不一直重做**compare操作**，可能导致该线程一直无法向前推进

## wait-free数据结构
- 定义
	在lock-free数据结构的基础上更进一步，线程不会出现饥饿现象。不管其他线程有什么行为，每个线程总能在某个时间段内完成其操作

# 无锁数据结构的优缺点
## 优点
1. 最大化并发，线程不用阻塞，每个线程各自完成自己的操作
2. 更加健壮
	对于有锁数据结构，如果一个线程占有锁的中途死掉了，则整个数据结构就被破坏了；无锁数据结构的一个线程死掉了则不会影响其他线程
3. 不会产生死锁
	因为无锁数据结构没有使用锁
## 缺点
1. 可能会降低整体性能，因为会用到很多原子变量和原子操作（相比于普通操作开销更大更耗时）
2. 可能产生活锁（两个线程同时尝试改变数据结构，结果每个线程都卡在compare和重做操作上）
3. 实现完善无data race，无bug的无锁数据结构很复杂，很困难


# 无锁数据结构的例子

# 设计无锁数据结构的指导