
## 在线程间共享数据的问题
- 如果共享数据是read-only的，那么不存在问题
- 出现问题只发生在有线程想要修改共享数据的时候
- 出现问题时往往会破坏"一致性"(例如多线程同时修改一个共享的双向链表时，可能会破坏链表的结构，这就是破坏了一致性),会带来未定义的行为甚至程序崩溃
### Race conditions:
- 产生的原因：
	程序运行的结果和多个线程执行的顺序有关
- 性质：
	有些竞争条件是良性的，不会破坏一致性
	真正需要关注的是恶性的会破坏程序一致性的竞争条件
	可能造成未定义的行为
- 产生的时机
	竞争条件出现在某个线程**修改**某个数据时，由于cpu执行非常快速，出现竞争条件的时间窗口很小。
	只有恰好某个线程在时间窗口内修改了数据时，才可能会产生竞争条件
	竞争条件产生的bug往往是很难复现的
- 解决恶性race conditions的方法
 1. 对共享数据添加保护机制
	 比如锁，保证每次只能由一个线程处于修改共享数据的状态
 2. 修改数据结构的设计，使得每次修改数据都是原子操作，不同线程的执行顺序不会破坏一致性（无锁编程）
 3. 使用事务机制（类似于数据库中事务的处理）
	 事务操作每次将修改操作放到一个transaction log，然后一次性commit。commit时比较数据的状态是否一致。

### 在C++中使用锁保护共享变量
- c++提供的锁：
	**std::mutex**
	应该使用std::lock_guard来使用锁保护共享变量。std::lock_guard是RAII思想的实现，在构造函数中调用mutex.lock()操作，在析构函数中调用mutex.unlock()操作。
	借助std::lock_guard来管理mutex可以避免忘记释放锁的情况
- 使用了锁也并不是万无一失
	即使对操作共享数据的每个成员函数都加锁了，也可能产生race conditions
	如何产生：
		当传递共享数据的指针或者引用到**锁的作用域之外**时，其他线程便可以不经过锁来操作共享数据。
	如何避免：
		1. 成员函数不要用共享数据的指针或者引用作为返回值
		2. 在成员函数内部不要将共享数据的指针或者引用传递给**其他函数**，因为其他函数可能会将共享数据暴露出去，使得其他线程可以轻易访问。
- 即使很好地使用了锁，也可能由于接口设计的不好导致race conditions
	- 每一个成员函数都良好地使用了锁，因此若多个线程同时调用同一个函数，不会出现问题。
	- 但是若多个线程同时调用多个不同的接口函数，若不同的接口互相影响，则线程执行的顺序不同，程序运行的结果可能不同。
	![[Pasted image 20220416115420.png]]
	- 如上图代码段所示：如果是单线程执行，不会有问题；如果是多线程执行，可能产生race conditions，例如另一个线程在1之后2之前执行了s.pop()操作，导致s为空了，则2处的s.top()操作会出问题。
	- 栈s的内部状态已经被锁保护好了，但是无法保证外部调用不同接口时产生的race conditions。