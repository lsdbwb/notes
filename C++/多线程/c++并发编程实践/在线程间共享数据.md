
## 在线程间共享数据的问题
- 如果共享数据是read-only的，那么不存在问题
- 出现问题只发生在有线程想要修改共享数据的时候
- 出现问题时往往会破坏"一致性"(例如多线程同时修改一个共享的双向链表时，可能会破坏链表的结构，这就是破坏了一致性),会带来未定义的行为甚至程序崩溃
### Race conditions:
- 产生的原因：
	程序运行的结果和多个线程执行的顺序有关
- 性质：
	有些竞争条件是良性的，不会破坏一致性
	真正需要关注的是恶性的会破坏程序一致性的竞争条件
	可能造成未定义的行为
- 产生的时机
	竞争条件出现在多个线程同时修改某个数据时，由于cpu执行非常快速，出现竞争条件的时间窗口很小。
	只有恰好多个线程在时间窗口内修改了数据时，才会产生竞争条件
	竞争条件产生的bug往往是很难复现的
- 解决恶性race conditions的方法
 1. 对共享数据添加保护机制
	 比如锁，保证每次只能由一个线程处于修改共享数据的状态
 2. 修改数据结构的设计，使得每次修改数据都是原子操作，不同线程的执行顺序不会破坏一致性
 3. 使用事务机制（类似于数据库中事务的处理）
	 事务操作每次将修改操作放到一个transaction log，然后一次性commit。commit时比较数据的状态是否一致。
