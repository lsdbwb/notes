# 多态的分类
多态 ：同一种事物可以表现出多种不同的行为 
## 静态多态
编译期
- 函数重载
	名称相同，参数不同的函数表现出不同的行为
	使用name mangling机制来实现
- 模板函数
	同一个函数，不同的参数类型表现出不同的行为
	通过模板类型推导机制实现
	
## 动态多态
执行期，也称为动态绑定
- 子类继承父类，子类重写父类的函数，在运行时根据实际对象的类型调用对应的函数
- c++使用虚函数、虚表来实现动态绑定


# c++动态绑定的实现
## 虚函数表
### 表结构
正常情况下只有最下面三项，当有虚继承时会出现上面两项
![[Pasted image 20220531200356.png]]

- offset to top : 对象在对象布局中到实际对象顶部地址的偏移量
- RTTI information ： 指向存储运行时类型信息(type_info)的地址，用于运行时类型识别，用于typeid和dynamic_cast
- virtual function pointers ： 虚函数指针

### 表创建时机
- 虚函数表是在编译器创建的，在编译阶段编译器就为每个类确定好了虚函数表里的内容
- 编译器只会为**有虚函数的类**创建虚函数表
- 虚函数表是和具体的类对应（不是和一个一个的类对象对应），虚函数表被放在程序的只读数据段中

### 一个对象在linux中的内存布局
```c++
// A是Derived的基类
A* a = new Derived();
```
![[Pasted image 20220531202057.png]]
1. 对象指针A* a存放在栈区，指针指向的对象存放在堆区
2. 该对象开头8字节放的是虚函数表的指针，该指针指向只读数据段里存放的Derived类的虚函数表
3. 虚函数表里的虚函数指针指向代码段里具体的函数

**构造函数为什么不能设置为虚函数**
- 对象在构造函数中设置vptr为该类的虚表对应的地址，相当于对于每个对象来说，必须在调用构造函数之后，才能找到并使用虚函数表
- 如果构造函数也是虚函数，那么调用构造函数就需要经过虚函数表，而此时虚函数表并不存在（相当于蛋生鸡鸡生蛋问题）


## 不同对象具体内存布局
不同类型的对象的内存布局不同

### 普通对象
因为C++的zero overhead abstract原则，c++普通对象的布局**和c里面struct的布局**是一样的。既然没有用到动态绑定的特性，也就不要引入动态绑定的运行时开销；所以普通对象因为没有虚函数，所以就不需要虚表，对象也不需要虚表指针

### 带虚函数的类对象
编译器检查到一个类有virtual关键字时，就会在编译器为该类生成虚函数表，同时该类的每个对象都会多一个虚表指针成员，指向虚函数表

![[Pasted image 20220531204320.png]]
- 虚表第一个entry是**offset_to_top** ， 表示vptr距离该对象顶部地址的偏移量offset
- 该对象的vptr就在对象的最顶部，因此offset为0


### 单继承下类对象布局
- 子类继承父类时，如果子类不重写父类的函数，则子类的虚表里存的函数指针和父类的虚表里存的一样
- 如果子类重写父类的某个函数，则子类虚函数表对应slot位置的函数指针会被替换为指向子类自己的函数
	每个虚函数在父类和子类的虚表的slot的值是一样的，是在编译器确定的
	
```c++
struct Base {
    Base() = default;
    virtual ~Base() = default;

    void FuncA() {}

    virtual void FuncB() {
        printf("Base FuncB\n");
    }

    int a;
    int b;
};

struct Derive : public Base{
};

int main() {
    Base a;
    Derive d;
    return 0; 
}
```

- 父类Base和子类Derive有各自的虚表
- 父类对象的vptr指向父类Base的虚表
![[Pasted image 20220531204940.png]]
- 子类对象的vptr指向子类Derive的虚表
- 子类重写了父类的FuncB函数，因此子类对应slot存的是重写后自己的FuncB
![[Pasted image 20220531205242.png]]

### 多继承下类对象布局
- 继承了几个类，就会有几个虚表指针
- 需要使用this+偏移量的方式从对象中找到虚表指针

Derive同时继承了BaseA类和BaseB类
Derive内存布局如下图左边所示，虚表结构如下图右边所示
![[Pasted image 20220531212602.png]]

-  可见此时出现了两个虚表指针，对应会出现以下两种情况
```c++
// 使用BaseA类型的指针指向Derive类型的对象
BaseA* ba = new Derive();
// 因为BaseA vptr就在Derive对象的顶部，offset为0，因此会调用上半部分虚表内的函数
ba->func();

// 使用BaseB类型的指针指向Derive类型的对象
BaseB* bb = new Derive();
// 此时应该调用下半部分虚表内的函数，可见offset为 -16，因此this指针要加上offset去指向BaseB vptr
bb->func();
```


### 虚继承下对象布局
虚继承是为了解决c++多重继承问题的手段，当子类从不同途径继承了基类多次，基类的成员会在子类对象中存在多份拷贝，浪费内存空间