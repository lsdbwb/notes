# 协程的概念
- 协程是允许执行被挂起和被恢复的子例程（subroutine）
- 协程可以看作一个特殊的函数。和普通的函数相比不同的是，普通的函数一旦被调用，则只能从头开始执行直到函数执行结束。协程则可以在运行过程中暂停运行（yield），让出cpu,后面再（yield）恢复执行。想要做到yield和resume操作，协程就需要在yield的时间点保存函数运行的状态，即函数运行的上下文

# 协程的分类
## 按每个携程是否有自己的栈
程序运行时一定是有栈的，无栈携程并不是说**运行时**没有栈，而是说在协程**挂起后**是否还需要栈
### 有栈协程
- 如下所示，协程的上下文包括函数的参数，函数返回地址和局部变量以及寄存器中的值。有栈协程有自己的栈空间（这块栈空间在堆上，堆内存要自己指定）
- 栈帧的起始地址和结束地址存放在ebp和esp这两个寄存器中
- 协程的栈内存空间存放的ebp esp的地址值指向的是其堆上的栈内存空间，相当于协程是运行在进程的heap区而不是原来运行在进程的stack区
![[Pasted image 20220511151045.png]]
#### 私有栈
每个携程在堆上都有自己独立的栈空间
- 每个协程都有自己独立的栈，互不影响
- 栈不能开很大，因为内存容量有限，开很大的话只能同时生成很少的协程
- 栈比较小因此有爆栈的风险
#### 共享栈
一组携程共享堆上一个较大的栈空间，共享栈每次只能被正在运行的协程使用。每次协程切换时，需要把切换出去的协程的内存拷贝到一个地方保存
- 优点是正在运行的协程的栈空间可以很大，不会有爆栈的风险。每次保存时计算协程真正使用的内存量，因此可以做到用多少存多少，避免了内存的浪费
- 缺点是相比有栈协程，每次运行时多了一次拷贝（从保存的位置拷贝到共享栈）

### 无栈协程
无栈协程是使用generator的方式

## 按协程间调度的方式
- 协程间的调度方式指的是多个协程的运行顺序，即协程在让出CPU时下一个执行的协程是谁
- 对称协程和非对称协程有相同的表达力，即一种类型可以转换为另一种类型
### 对称协程
- 所有的协程的地位都是对等的
- 协程只有yield操作，用于将执行流让给其他协程
- 对称协程一般需要一个调度器的支持，在一个协程让出cpu后，调度其他协程执行
![[Pasted image 20220511171138.png]]

### 非对称协程
- 提供了两种操作：resume和yield操作
- **控制协程**使用resume操作将程序控制流转移给某个协程后，该协程只能调用yield将控制流还给控制协程，然后控制线程再调度其他协程
![[Pasted image 20220511171438.png]]

# 协程上下文切换的方式
## 使用操作系统提供的api
- linux : u_context[[ucontext_h相关api]]
- windows : fiber
安全可靠，使用简单，但是性能较差(切换性能大概在200万次/秒左右)
## 使用setjump、longjump
## 自己使用汇编代码实现
- libco
性能很好，但是针对不同的架构，不同的系统甚至不同的linux版本都得有不同的汇编代码，兼容性较差
## 使用boost.coroutine
这种方式的性能很好，boost也帮忙处理了各种平台架构的兼容性问题，缺陷是这东西随着boost的升级，并不是向后兼容的，不推荐使用
##  使用boost.context
性能、兼容性都是当前最佳的，推荐使用。（切换性能大概在1.25亿次/秒左右)