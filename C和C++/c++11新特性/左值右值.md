# 左值右值的概念
在c语言中，能够放在表达式左边的就是左值，而右值就是放到表达式右边的值。为了表达对象是否可以移动，c++为左值和右值赋予了新的概念

## C++中值的分类
### C++中的值有两个**独立的**属性
1. 有身份
	- 有身份的意思就是有地址，可以有指向它的指针
	- 有身份的值被统称为glvalue(“generalized“ left valu)
2. 可以被移动
	- 可以被移动的值统称为右值(rvalue)


### 根据以上两个属性，C++把值划分为以下几类
![[Pasted image 20220713204048.png]]
1. lvalue(左值) ： 有身份但是不能被移动
	包括：
	- 变量，函数和数据成员的名字
	- 返回左值引用的表达式，比如++x,cout << "xx"，x=1
	- 字符串字面量，如 "hello world"

2. prvalue（纯右值）：没有身份但是可以被移动，也就是所谓的临时变量
	包括：
	- 返回非引用类型的表达式：x++, x+1
	- 除了字符串字面量以外的字面量：true,42
	
	> this指针也是纯右值，没法对this指针取地址

3. xvalue（将亡值）：有身份并且可以被移动
	例如：
	- 右值引用类型的返回值：std::move(x)


### 区分左值右值的办法
实践中，可以使用以下法则区分左值右值：
1. 如果可以对某个表达式取地址，那么其是左值
2. 如果一个表达式的类型是左值引用（T&或const T&),那么他是左值
3. 否则，这个表达式是右值
	- 函数的返回值（非引用类型或者右值引用类型）
	- 通过隐式类型转换创造的值
	- 大多数字面量


# 左值引用和右值引用
左值引用（T&或const T&）
右值引用（T&&或const T&&）
1. 右值引用只能绑定到右值上
2. 非const的左值引用只能绑定到左值上
3. const的左值引用可以绑定到右值

- 左值引用变量和右值引用变量本身都是左值，因为都有身份（可以取地址）
- 如果将某个prvalue绑定到引用上，那么该prvalue的*生命周期会变得和引用一样长*


# 移动构造和移动赋值函数
c++11引入右值和移动的概念的同时，给一个类新增了特殊的成员函数，即移动构造函数和移动赋值函数
```c++
class Widget{
public:
	Widget(Widget&& w) = default;
	widget& operator=(Widget&& w) = default;
};
```

## 移动构造函数的任务
- 完成资源移动
	- 资源的所有权交给新创建的对象
- 确保移动操作完成后，销毁源对象是无害的
	- 源对象不再指向资源
- 确保移动操作完成后，源对象依然是有效的
	- 可以赋予一个新值
	- 留下的值没有任何要求


## 移动操作和异常安全
- 移动操作一般不新分配新资源，因此通常不会抛出异常
- 如果移动操作不抛出异常，**必须注明noexcept**（否则标准库不敢调用你的移动构造函数）

标准库的某些接口会做出异常安全的保证，以vector的push_back为例：
![[Pasted image 20220713213550.png]]
也就是说，当由于元素分配、拷贝或者移动操作产生异常时，这个调用*不产生任何效果*


>异常安全保证的三个等级：
>1. 基础保证
>	异常抛出时，程序中的一切保持在有效的状态（可能发生了改变）
>2. 强保证
>	异常抛出时，程序的状态不变
>	称这样的调用是原子的，成功时将被完整执行；失败时恢复到原来的状态，好像调用没有发生一样
>3. 保证不抛异常
>	所有对内部类型的操作都是不抛异常的

vector的push_back是强异常安全保证的


## 移动操作和函数匹配
- 移动右值，拷贝左值
	移动构造函数的实参必须是右值，其他情况下都会发生拷贝
- 如果没有定义移动构造，则右值也被拷贝
	拷贝构造函数的参数是const的左值引用，既能接受左值作为实参，也能接受右值作为实参

## 移动赋值运算符
定义不抛异常的移动赋值运算符最简单的方法就是定义一个”**拷贝并交换**“的拷贝赋值运算符(既可以处理拷贝，也可以处理移动)
```c++
ClassA& ClassA::operator=(ClassA rhs) {
	swap(*this, rhs);
	return *this;
}

ClassA a;
Class b;
b = a;  // 当右侧对象是左值时，构造rhs时调用拷贝构造
b = std::move(a); // 当右侧对象是右值时，构造rhs时调用移动构造
```
1. 赋值运算符的参数不再是引用，而是传值
2. rhs将是右侧运算对象a的一个副本
3. swap操作之后，rhs的资源被移交到`*this`即当前对象。rhs则指向当前对象的资源
4. 该函数返回时,rhs会被销毁，即销毁了原来`*this`对象指向的内存


>如何定义一个不抛异常的swap操作



## 该如何定义移动构造/赋值
### the rule of zero
如果默认行为够用，那么就不要再定义自己的特殊成员函数

### the rule of five
如果定义了拷贝、移动或者析构中的任意一个，或者将任意一个声明为delete的，那么其他所有的都需要定义出来或者声明为delete的

如果需要默认行为，就声明为default；如果想要禁用，就声明为delete（这两种情况都被认为是用户自定义的）

![[Pasted image 20220713223403.png]]
![[Pasted image 20220713223421.png]]