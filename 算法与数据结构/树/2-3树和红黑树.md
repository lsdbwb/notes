# 提出2-3树和红黑树的原因
- 二叉查找树在最差的情况下会退化为链表，此时查询操作的复杂度由O(logN)退化为O(N)
- 二叉平衡树能够保证树的**完美平衡**，但是条件过于严苛(左右子树的高度差小于等于1)，几乎在每次插入和删除操作时都需要进行复杂的调整操作（插入和删除并不一定是O(logN)的）
- 因此提出了2-3树，稍稍放松了完美平衡的要求，但是保证查询、插入、删除等操作的时间复杂度都为O(logN)

# 2-3树
为了保证树的平衡性而增加了一些灵活性，引入了3-节点
![[Pasted image 20220604153929.png]]
- **一颗完美平衡的2-3树**的所有空链接到根节点的距离是**相同**的

## 2-3树的查找
查找流程和正常的二叉搜索树是差不多的，只不过3-节点中有两个元素，有三个叶子节点

## 2-3树的插入
- 普通的二叉搜索树在插入时会先进行一次未命中的查找，然后将新节点作为叶子节点挂在树的底部，这样便破坏了树的平衡性
- 2-3树在插入时能够保证树的平衡
### 插入到2-节点
很简单，只需要将2-节点替换为一个新的含有插入元素的3-节点即可
![[Pasted image 20220604155229.png]]
### 插入到3-节点
分多种情况，但基本操作都是将3-节点变成4-节点然后进行分裂
1. **只含有一个3-节点**
![[Pasted image 20220604155604.png]]
2. **向一个父节点为2-节点的3-节点插入**
![[Pasted image 20220604155653.png]]

3. **向一个父节点为3-节点的3-节点插入**
向上不断扩展
![[Pasted image 20220604155901.png]]

4. **如果父节点也是3-节点，则父节点进行分解**
![[Pasted image 20220604160020.png]]

### 2-3树的插入操作是局部变换
- 4-节点的分解操作是一次**局部变换**，除了相关的节点和链接之外不会影响树中其他的节点
![[Pasted image 20220604160347.png]]
- 4-节点的分解操作不用会影响树的高度，只有当根节点被分解为3个2-节点时，整棵树的高度才会加1

## 查找和插入操作的总结
**根据以上查找和插入操作的分析，即使在最坏情况下，2-3树也能保证这两个操作为o(logn)的时间复杂度**
- 每个操作中处理每个节点的时间复杂度都是很小的常数
- 这两个操作都只会访问同一条路径上的节点

**2-3树的概念很好理解，但是代码实现起来比较复杂**
如果用最直白的方式来实现
- 需要维护2-节点和3-节点两种节点类型
- 需要一种节点类型转换为另一种节点类型
- 需要复制和搬移一个节点的信息到另一个节点
实现这些需要复杂的代码，并且带来的额外开销可能使得实际的复杂度增大

## 2-3树的删除



# 红黑树的概念
红黑树其实就是2-3树演变而来

## 为什么需要红黑树
- 2-3树概念简单但如果使用最直白的方式实现起来会很复杂，并且复杂的代码可能带来额外的开销，所以希望能用简单的方式来实现2-3树

**因此红黑树的基本思想就是仍然用二叉查找树(2-节点)加一些额外的信息（表示3-节点）来表示2-3树**

## 2-3树演变为红黑树
### 替换3-节点
如下所示，将3-节点替换为**两个2-节点加一个红链接**来表示
![[Pasted image 20220604163348.png]]

### 红黑树的另一种定义
按上述替换3-节点的方法，可以得到另外一种红黑树的定义
**含有红黑链接并且**满足以下条件的二叉查找树
1. 红链接均为左链接
2. 没有任何一个节点同时和两个红链接相连
3. 该树是**完美黑色平衡**的，即所有空链接到根节点的黑链接的数量是相同的


![[Pasted image 20220604164136.png]]
![[Pasted image 20220604164512.png]]
只要保证和2-3树定义的对应，则红黑树既是一颗二叉查找树，也是一颗2-3树。因此能够同时拥有二者的优点：二叉查找树高效的**查找**操作和2-3树高效的**平衡插入**操作

## 红黑树的实现
- 跟据上面红黑树和2-3树的一一对应的关系，将红链接画平时，就变成了一颗2-3树，红链接连接的两个节点共同组成一个3-节点
- 在实现某些操作时可能会出现红色右链接或者连续两条红链接，在操作完成前都会小心地使用**旋转操作**进行修复。旋转操作会改变红链接的指向
### 基本的旋转操作
- 左旋转h的右链接
- 右旋转h的左链接
![[Pasted image 20220609172929.png]]
旋转操作可以保证红黑树的两个重要性质，即有序性和完美平衡性

### 保证红黑树另外两个性质
- 没有红色的右链接
- 没有连续两个红链接
**向单个2-节点插入一个新键的情况**：
![[Pasted image 20220609173240.png]]
**向单个3-节点插入一个新键的情况**：
![[Pasted image 20220609173517.png]]
最简单的情况，如下所示：进行颜色转换
![[Pasted image 20220609173649.png]]

- 最终三种情况都会变为左右子节点都为红链接的情况
- 如果左右两个节点都是红链接，则将这两个节点都**变为黑链接**，同时中间节点变成红链接，相当于将它送入了父节点。这意味着在父节点中插入了一个新键，然后会递归地用相同的方法解决问题

**红链接递归向上传递**
![[Pasted image 20220609175104.png]]
1. 如果右子节点是红色，左子节点是黑色，则进行左旋转
2. 如果左子节点是红色并且其子节点也是红色，则进行右旋转
3. 如果左右子节点都是红色，则会进行颜色转换

## 红黑树最终的定义
红黑**链接**最终转变为由红黑节点来表示
红黑树是**完美黑色平衡**的
![[Pasted image 20220604170502.png]]
1）每个结点要么是红的，要么是黑的。  
2）根结点是黑的。  
3）每个叶结点，即空结点（NIL）是黑的。  
4）如果一个结点是红的，那么它的俩个儿子都是黑的。  
5）对每个结点，从该结点到其子孙结点的所有路径上**包含相同数目的黑结点**
这些红黑节点的定义其实和红黑链接的定义是一致的，因此保证了和2-3树的一一对应

**提示**：
可以看到上面这张图是可以有红色的右链接以及4-节点（左右两边都是红色节点）的。只允许红色左链接的存在能够减少可能出现的情况，因此实现所需的代码会少的多

# 红黑树的优势
- 红黑树只在插入操作时引入了旋转和颜色变换操作，在做各种查询操作时和二叉搜索树都是一样的，不会引入任何开销
- 红黑树在最坏情况下仍然能够保持平衡，保证查询、插入、删除操作的时间复杂度为O(logN)



# 总结
![[Pasted image 20220604170019.png]]