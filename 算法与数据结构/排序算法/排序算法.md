排序用到两个基本操作：比较和交换

# 选择排序
## 概念描述
每次从所有元素中选择一个最小的元素，该最小的元素和数组中的第一个元素进行交换（如果最小的元素就是第一个元素，则和自己交换）；接着从数组中从第二个元素开始寻找最小元素，并做相同的操作；循环往复，直到确定所有元素的顺序

## 时空复杂度
每次选择排序需要进行约N^2/2次比较操作和N次交换操作

## 特点
**1. 运行时间和输入无关**
	无论输入的分布是怎样的，选择排序的流程都是一样的，并且比较操作和交换操作的次数也是固定的
**2. 交换次数是最少的，只用了N次交换**

## 代码模板
```c++
class Selection
{
public:
	void sort(std::vector<T>& input){
		int n = input.size();
		for(int i = 0; i < n; i++){
			int min_pos = i;
			// 寻找最小元素的位置
			for(int j = i+1; j < n; j++){
				if(less(input[j], input[i])){
					min_pos = j;
				}
			}
			exchange(input, i, min_pos);
		}
	}
};
//less表示比较函数
//exchange表示交换两个位置的元素
```

# 插入排序
## 概念
每次将当前的数插入到该数左边已经部分有序的数组中

## 特点
1. **当前处理的元素的左边的所有元素都是有序的，但是不一定在最终位置**
2. 将当前元素插入到左边部分有序的元素时，左边的元素可能要进行移动以腾出位置
3. 插入排序的时间**取决于元素的初始顺序**，如果数组初始已经近似有序，则插入排序的时间复杂度可以接近O(N)

## 时间复杂度
![[Pasted image 20220604180101.png]]

## 代码模板
```c++
class Insertion
{
public:
	void sort(vector<T> input){
		int n = input.size();
		for(int i = 1; i < n; i++){
		// 将input[i] 插入到 input[0],input[1] ... input[i-1]中
			for(int j = i; j > 0; j--){
				if(less(input[j], input[j-1])){
					exchange(input, j,j-1);
				}
			}
		}
	}
};
//less表示比较函数
//exchange表示交换两个位置的元素
```

**当数据随机分布时，插入排序比选择排序快一倍左右**

# 希尔排序


# 归并排序


# 快速排序

