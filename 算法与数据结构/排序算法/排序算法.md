# 排序算法一览
![[Pasted image 20220605172646.png]]
- 只有插入排序和归并排序是稳定的
- 快速排序是最快的通用排序算法
![[Pasted image 20220605172805.png]]

# 选择排序
## 概念描述
每次从所有元素中选择一个最小的元素，该最小的元素和数组中的第一个元素进行交换（如果最小的元素就是第一个元素，则和自己交换）；接着从数组中从第二个元素开始寻找最小元素，并做相同的操作；循环往复，直到确定所有元素的顺序

## 时空复杂度
每次选择排序需要进行约N^2/2次比较操作和N次交换操作

## 特点
**1. 运行时间和输入无关**
	无论输入的分布是怎样的，选择排序的流程都是一样的，并且比较操作和交换操作的次数也是固定的
**2. 交换次数是最少的，只用了N次交换**

## 代码模板
```c++
class Selection
{
public:
	void sort(std::vector<T>& input){
		int n = input.size();
		for(int i = 0; i < n; i++){
			int min_pos = i;
			// 寻找最小元素的位置
			for(int j = i+1; j < n; j++){
				if(less(input[j], input[i])){
					min_pos = j;
				}
			}
			exchange(input, i, min_pos);
		}
	}
};
// 排序用到比较和交换两种基本操作
//less表示比较函数
//exchange表示交换两个位置的元素
```

# 插入排序
## 概念
每次将当前的数插入到该数左边已经部分有序的数组中

## 特点
1. **当前处理的元素的左边的所有元素都是有序的，但是不一定在最终位置**
2. 将当前元素插入到左边部分有序的元素时，左边的元素可能要进行移动以腾出位置
3. 插入排序的时间**取决于元素的初始顺序**，如果数组初始已经近似有序，则插入排序的时间复杂度可以接近O(N)

## 时间复杂度
![[Pasted image 20220604180101.png]]

## 代码模板
```c++
class Insertion
{
public:
	void sort(vector<T> input){
		int n = input.size();
		for(int i = 1; i < n; i++){
		// 将input[i] 插入到 input[0],input[1] ... input[i-1]中
			for(int j = i; j > 0; j--){
				if(less(input[j], input[j-1])){
					exchange(input, j,j-1);
				}
			}
		}
	}
};
//less表示比较函数
//exchange表示交换两个位置的元素
```

**当数据随机分布时，插入排序比选择排序快一倍左右**

# 希尔排序
## 概念
- 希尔排序基于插入排序来实现
- 插入排序对于已经基本有序的数组进行排序时效率很高，因此希尔排序的思想就是先把数组变得**局部有序**
- 插入排序每次都和相邻的元素进行比较，希尔排序则是先对不相邻的元素进行比较，使得数组整体上局部有序，最后再使用插入排序对局部有序的数组进行排序

如下图所示，希尔排序使得任意间隔为h的元素都是有序的
![[Pasted image 20220605102056.png]]
- h是一个递增序列，希尔排序的间隔从1开始到某个数m；在进行排序时先从间隔m开始，最终间隔为1时就是进行一遍插入排序
- 间隔为m进行排序时，和插入排序的思想一样，只不过是每次进行交换的距离由1变为m

## 时间复杂度
- 希尔排序的时间复杂度尚无定论，但是不会到达O(N^2)的级别
- 递增序列影响希尔排序的效率，递增序列的好坏不仅取决于h的值，也取决于h之间的数学性质

## 代码模板
```c++
class Shell
{
public:
	void sort(vector<T>& nums){
		int n = nums.size();
		// 计算间隔
		int h = 1;
		while(h < n / 3) h = 3*h + 1; // 1,4,13,40,121,364...
		while(h >= 1){
			// 将数组变得h有序
			for(int i = h; i < n; i++){
			//将nums[i]和nums[i-h], nums[i-2*h]...nums[i-m*h]进行交换
				for(int j = i; j >= h; j -= h){
					if(less(nums[j], nums[j-h])){
						exchange(nums, j, j - h);
					}
				}
			}
		}
		
	}
};
//less表示比较函数
//exchange表示交换两个位置的元素
```

**结论**
- 在中等规模的数组上使用希尔排序的时间是可以接受的
- 在大规模的数组上，归并和快排比希尔排序最多快2倍（可能还不到）
- 希尔排序的代码量很小，实现起来很简单，并且不需要额外的存储空间

# 归并排序
## 概念
将一个数组排序，可以递归地先将该数组分成两部分，将左半部分和右半部分分别排序好后，再归并结果
![[Pasted image 20220605105100.png]]

## 归并操作
1. 最简单的方法：将两个有序数组归并到第三个数组中
	在很大的数组上进行排序时，每一层递归都要进行归并，每一次归并都需要一个创建一个新的数组来存储结果
	
2. 原地归并 ：就在原数组上进行归并操作
	不需要额外的空间，但是实现起来比较复杂

使用一个**辅助数组**的原地归并操作
```c++
void merge(vector<T& nums, int left, int mid, int right){
// 将nums[left..mid]和nums[mid+1..right]进行归并
	int i = left;
	int j = mid + 1;
	// 每次先将原数组的内容复制到辅助数组
	for(int k = left; k <= right; k++){
		aux[k] = nums[k];
	}
	// 归并操作
	for(int k = left; k <= right; k++){
		if(i > mid)                   nums[k] = aux[j++];
		else if(j > right)            nums[k] = aux[i++];
		else if(less(aux[i], aux[j])) nums[k] = aux[i++];
		else                          nums[k] = aux[j++];
	}
} 
```
## 拆分操作
### 递归：自顶向下
```c++
class RecurMerge
{
public:
	void sort(vector<T>& nums){
		aux.resize(nums.size());
		sort(nums, 0, nums.size() - 1);
	}
	void sort(vector<T>& nums, int left, int right){
		//递归结束
		if(left > right) return;
		int mid = left + (right - left) / 2;
		// 先递归排序左边
		sort(nums, left, mid);
		// 再递归排序右边
		sort(mid+1, right);
		// 合并两个已排序数组
		merge(nums, left, mid, right);
	}
private:
	// 归并需要的辅助数组
	vector<T> aux;
};
```

对于长度为N的任意数组，自顶向下的归并排序需要**1/2NlogN~NlogN**次比较
![[Pasted image 20220605112907.png]]

![[Pasted image 20220605113209.png]]

### 迭代：自底向上
递归是自顶向下分而治之的思想
可以使用自底向上的迭代的方法来模拟这一过程：先一一合并，再两两合并，再四四合并，再八八合并直到最终合并完成
![[Pasted image 20220605115751.png]]

**代码模板**
```c++
class Merge
{
public:
	void sort(vector<T>& nums){
		//为辅助数组分配空间
		int n = nums.size();
		aux.resize(n);
		//进行logN次两两归并
		for(int sz = 1; sz < n; sz += sz){
			for(int lo = 0; lo < n-sz; lo += sz+sz){
				merge(nums, lo, lo + sz - 1, 
						min(lo + sz+sz -1, n-1));
			}
		}
	}
	
	void sort(vector<T>& nums, int left, int right){

	}
private:
	// 归并需要的辅助数组
	vector<T> aux;
};
```

**自底向上的方法非常适合进行链表的归并排序，只需要重新组织链表链接，不需要额外的链表节点**
	长度为1的链表归并成长度为2的链表，长度为2的链表归并为长度为4的链表...以此类推

## 时空复杂度
递归法：时间复杂度为O(NlogN)，空间复杂度为O(N)
迭代法：时间复杂度为O(NlogN)，空间复杂度为O(N)
在数组长度为2的幂时，两种方法的比较次数和访问数组的次数一样

## 优化归并排序
### 对小规模子数组使用插入排序
**递归会使得小规模数组中的函数调用过于频繁，影响性能**
对于小规模数组（例如长度小于15）使用插入排序一般能够将归并排序的时间优化10%~15%

###  测试数组是否已经有序
因为merge操作是对两个有序数组进行merge，如果左边数组的最大值`nums[mid]`已经小于右边数组的最小值`nums[mid+1]`,就不需要进行merge操作了

### 不将元素复制到辅助数组
并不是不使用辅助数组，辅助数组的空间无法节省
但是可以节省拷贝到辅助数组的次数
![[Pasted image 20220605115113.png]]

# 快速排序
## 特点
**优点**
- 实现简单
- 适用于各种不同的数据，并且比大部分排序算法都要快
- 原地排序，只需要很小的辅助栈
- 将长度为N的数组进行排序所需的时间是O(NlogN)级别
- 内循环相比于其他排序算法都要短小，因此无论在理论上还是实践上都很快
**缺点**
- 脆弱，在一些场景下会退化为O(N^2)的时间复杂度

## 概念
大致流程：
![[Pasted image 20220605122442.png]]
1. 每次从数组中选一个数作为pivot
2. 将整个数组切分为两部分：比pivot小的部分和比pivot大的部分
3. 然后递归处理左数组和右数组

## 代码模板
```c++
class QuickSort
{
public:
	void sort(vector<T>& nums){
		sort(nums, 0, nums.size() - 1);
	}
	void sort(vector<T>& nums, int lo, int hi){
		if(lo >= hi) return;
		// 切分
		int pos = partition(nums, lo, hi);
		// 递归排序左半部分
		sort(nums, lo, pos-1);
		// 递归排序右半部分
		sort(nums, pos+1, hi);
	} 
};
```

## 关键：切分(partition)
![[Pasted image 20220605160921.png]]
快速排序就是通过递归地切分来进行排序的

**切分的过程**
![[Pasted image 20220605161049.png]]
1. 先取数组的第一个元素为pivot
2. 用两个指针，左指针从左往右扫描，直到找到第一个大于大于等于pivot的元素
3. 右指针从右往左扫描，直到找到第一个小于等于pivot的元素
4. 然后交换左右指针指向的元素

```c++
int partition(vector<T>& nums, int lo, int hi){
	//将数组切分为a[lo..mid] a[mid] a[mid+1..hi]
	int i = lo;
	int j = hi + 1;
	T pivot = nums[lo];
	while(true){
		while(less(nums[++i], pivot)) if(i == hi) break;
		while(less(pivot, nums[--j])) if(j == lo) break;
		if(i >= j) break;
		exchange(nums, i, j);
	}
	// 将pivot放到合适的位置
	echange(nums, lo, j);
	// 返回pivot更新的位置
	return j;
}
```


## 总结
![[Pasted image 20220605163545.png]]
- 当数组本身已经接近有序时，快速排序最多需要约N^2/2次比较
- 当数组的分布比较随机时，快速排序的效果越好（在进行paitition选取pivot时每次pivot的位置都在数组的中间）

## 改进快速排序
### 对小数组使用插入排序
![[Pasted image 20220605164017.png]]

### 三取样切分
选取子数组的中位数作为pivot（使得切分效果更好，但是计算中位数会增加额外的计算量）
- 从待切分的子数组中选取小部分数的中位数作为pivot
- 取样值为3并用大小居中的元素时效果最好


### 熵最优的排序
- 实际的数组中常常含有大量重复的元素
- 对于一个全是重复元素的子数组，快速排序仍然会递归地去切分，造成了大量的重复无效计算
- 可以利用数组中含有大量重复元素这一先验信息来加速

#### 三向切分法
如下图所示，切分后和pivot相等的值都在中间，左边都是小于pivot的值，右边都是大于pivot的值
相当于一次性把重复元素的位置都确定了，这样这些重复元素都不会进入后面的递归计算

**三向切分步骤**
![[Pasted image 20220605165441.png]]
![[Pasted image 20220605170225.png]]
```c++
class Quick_3_way{
public:
void sort(vector<T>& nums, int lo, int hi){
	if(hi >= lo) return;
	int lt = lo;
	int gt = hi;
	int i = lo + 1;
	T pivot = nums[lo];
	while(i <= gt){
		if(nums[i] < pivot){
			exchange(nums, i++, lt++);
		}else if(nums[i] > pivot){
			exchange(nums, i++, gt++);
		}else{
			i++;
		}
	}
	// 递归调用
	sort(nums, lo, lt-1);
	sort(nums, gt+1, hi);
}
};
```

**对于大量重复的元素，三向切分将排序时间由线性对数级别下降到了线性级别**

# 优先队列





