# TCP的状态定义和状态转换
![[Pasted image 20220703105939.png]]
- 黑色实线表示客户端正常的状态转变
- 黑色虚线表示服务端正常的状态转变
如上图所示，TCP一共定义了11种状态。TCP的状态反映了TCP当前的工作情况。状态之间有比较复杂的转变，主要反映TCP从*建立连接到正常收发数据再到断开连接的过程。*
TCP是全双工的，因此通信双方都是**对等的**，上述状态通信双方都可以经历。只是因为目前常使用的是*客户端-服务端通信模式*，通常指定服务端作为被动接受连接的一方，指定客户端作为主动发起连接的一方。

## 十一种状态的定义
1. CLOSED：连接关闭时处于该状态，不是一个真正的状态，而是状态图假想的起点和终点
**建立连接时的状态**：
2. LISTEN: 服务端等待连接的状态。在经过socket、bind、listen三个系统调用后进入此状态,等待客户端发来的请求。此时称为应用被动打开
3. SYN_SENT：发送SYN报文后进入此状态。如果此时应用close或者SYN报文超时未确认，则直接进入CLOSED状态
4. SYN_RECVD：收到SYN报文后进入此状态。如果此时收到RST报文，服务端会重新变成LISTEN状态
5. ESTABLISHED：主动发起连接的一方在收到对方发送过来的ACK+SYN后就从SYN_SENT进入了ESTABLISHED状态。被动接受连接的一方，收到ACK后也进入ESTABLISHED状态。该状态是TCP连接*正常收发报文时*所处的状态。
**关闭连接时的状态：** 应用主动调用close时，向对端发送一个FIN报文，然后进入关闭连接的流程
6. FIN_WAIT1：主动发送FIN的一方先进入此状态，等待FIN的ACK报文
7. FIN_WAIT2：主动发送FIN的一方接收到FIN的ACK报文后进入此状态
8. CLOSING：主动发送FIN的一方没有收到ACK，反而收到了对端发送过来的FIN。说明对端也想关闭TCP连接，此时进入该状态，并且发送ACK给对端。（这时两方都处于CLOSING状态，即同时关闭，收到对方的ACK后，都进入TIME_WAIT状态）
9. TIME_WAIT ： 主动发起FIN关闭连接的那一方最终都会进入TIME_WAIT状态
	-   由CLOSING进入：
> “同时发起关闭情况下，当主动端接收到ACK后，进入此状态，实际上这里的同时是这样的情况：客户端发起关闭请求，发送FIN之后等待服务器端回应ACK，但此时服务器端同时也发起关闭请求，也发送了FIN，并且被客户端先于ACK接收到  
> ”
-   由FIN_WAIT_1进入：
> “发起关闭后，发送了FIN，等待ACK的时候，正好被动方（服务器端）也发起关闭请求，发送了FIN，这时客户端接收到了先前ACK，也收到了对方的FIN，然后发送ACK（对对方FIN的回应），与CLOSING进入的状态不同的是接收到FIN和ACK的先后顺序  
> ”
-   由FIN_WAIT_2进入：
> “这是不同时的情况，主动方在完成自身发起的主动关闭请求后，接收到了对方发送过来的FIN，然后回应 ACK  
> ”

10. CLOSE_WAIT:  被动关闭连接的一方收到FIN报文后进入此状态
11. LAST_CHECK ：被动关闭连接的一方发送FIN后进入此状态。在收到发送出去的FIN的ACK后，被动关闭连接的一方正常结束TCP连接


