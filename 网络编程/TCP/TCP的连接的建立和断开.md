# TCP连接为什么需要建立和断开的过程
## 从分布式共识的层面
三次握手、四次挥手都是对**Two Generals Problem的**工程上的折衷解决方案
>**Two Generals Problem（两将军问题）：**[[两将军问题(Two General's Problem)]]
>是计算机领域中的一个思想实验。旨在说明试图通过不可靠的链接进行通信来协调行动的陷阱和挑战。两位将军的问题是第一个被证明无法解决的计算机通信问题。

- 三次握手就是TCP连接的两端通过**不可靠的网络通信**交换各自的状态，进行沟通协调，确定双方都准备好可靠地传输TCP报文了
- 四次挥手同样是通过网络通信沟通协调，尽量使得TCP连接正常终止

## 从网络协议栈和TCP本身的层面
TCP是面向连接的、可靠的、基于字节流的传输层通信协议。在不可靠传输的IP层之上构建了可靠的传输。TCP连接并不是通过改变网络层及以下的更底层的通信协议来保证可靠，而是通过自身的设计来保持可靠。

建立一个TCP连接需要通信双方完成以下几个信息的**共识**：
- socket信息：IP地址和端口号
- 序列号(sequence number)：解决乱序问题
- 窗口大小：用来做流量控制

断开一个TCP连接则是希望通信双方能够**正常终止**，正常终止至少需要以下条件（对通信的每一方而言）：
- 所有需要接收的报文都已经正常接收完成
- 所有需要发送的报文已经正常发送给对方，并且收到对方的确认
- 其中一方都认为对方肯定会按照上述正常流程来进行

# 建立连接：三次握手
## 三次握手是两将军问题的一个工程解
上面已经描述了三次握手实际上是TCP双方想要通过不可靠的网络通信对TCP连接的一些必须的信息达成共识。
1. *通信的一方必须确保对方收到了自己发送的信息*，TCP是通过序列号sequence number和确认号ACK number来保证的，即发送方发送的每一条消息都带有序列号，每一条消息必须被对方确认，即发送方必须收到接收方对该条消息的确认消息
2. 因为通信时的消息在网络状况较差时可能会丢失，因此使用**超时重传机制**，发送方的一条消息如果经过一段特定的时间未被接收方确认，则发送方需要重传该条消息，直到收到接收方的确认消息为止

## 三次握手的状态转换
三次握手的过程和状态图如下：
![[Pasted image 20220704100300.png]]

## 为什么需要三次握手
1. 需要同步TCP连接双方的信息，主要是初始序列号ISN和窗口大小。
- 首先发送方和接收方首先都*必须发送自己的相关信息给对方*，这就是两次握手了。
- 然后发送方和接收方都必须发送ack来告知对方自己收到了对方的消息，对方的信息我已经知道了，这又是两次握手。
- 因为被动接收连接的一方可以把自己的信息和第一次握手的确认放在一个报文发送，所以可以减少一次握手。
	
2. TCP**序列号+确认**的机制可以防止在握手过程中旧的连接被重复初始化造成混乱
![[Pasted image 20220704105703.png]]
	如上图所示，TCP连接第一次握手的消息可能在*网络中被延迟了*，一段时间后发起连接的一方没有收到第一次握手的确认消息，于是触发重传机制，重新发送一个新的握手报文，这个报文的ISN和网络中被延迟的报文的ISN不同。
	被网络阻塞的报文先到达了，服务端发送该报文的确认报文给客户端，*客户端通过上下文比较*，发现自己期望收到的ACK NUM和该报文里的不一样，于是发起了RST报文中止连接
	
**TCP每次的初始序列号ISN是随机的**
1. 为了防止历史报文被相同的四元组指示的新的TCP连接接收
2. 为了安全性，防止黑客伪造相同TCP序列号的报文被对方接收

# 关闭连接：四次挥手
四次挥手用来正常且优雅地关闭TCP连接
## 为什么需要四次挥手
对TCP连接的两个endpoint而言，TCP连接的正常终止需要以下前提条件（对通信的每一方而言）：
- 所有需要接收的报文都已经正常接收完成
- 所有需要发送的报文已经正常发送给对方，并且收到对方的确认

以客户端主动关闭连接为例：
1. 客户端首先发送FIN：表示服务端先前发送的报文我都已经接收到了；表示我这边也没有报文想发送给服务端了
2. 服务端收到客户端的FIN报文后，便理解了上述客户端在FIN报文里蕴含的信息。因此需要发送确认ack报文，告知客户端我已经收到了你的FIN报文，知道了你想要关闭TCP连接的想法。
	并且服务端发送的对FIN报文的ACK报文的sequence number一定是最新的，说明FIN之前客户端发送的报文服务端都收到了，这使得服务端满足了上面的第一个条件；并且使得客户端满足了上面第二个条件。
3. 服务端此时可能不会立即去关闭连接，因为对于服务端而言，可能此刻他还没准备好关闭连接(*可能上层应用还未处理完毕*)，服务端此刻还不满足正常终止的条件（即服务端发给客户端的某些报文还没收到ack报文或者这边还想要继续发送更多的报文（客户端只关闭了写端没关闭读端[[socket相关api#shutdown函数]]））
4. 服务端接着发送FIN报文，表示我这边也没有报文想发送给客户端了。客户端收到服务端的FIN后，知道了服务端也准备好关闭TCP连接了，于是发送ack告知服务端我收到了你想要关闭连接的消息，你可以正常关闭了。于是服务端收到ack后就正常关闭连接。

	因为客户端最后发送的ACK可能会丢失，所以主动发起关闭连接的会进入TIME_WAIT状态，服务端一直收不到最后的ACK就会重传FIN，处于TIME_WAIT状态的客户端就会重传ACK，直到保证服务端最终收到ACK。
	
## 四次挥手的状态转换
![[Pasted image 20220704142151.png]]

## 为什么需要TIME_WAIT
观察上面的状态转换图可以知道，在客户端收到服务端发送的FIN过来之后，对于客户端而言，其正常终止的两个条件已经满足了（服务端发送FIN表示他不会再发送其他报文给客户端了）

1. **客户端不直接进入CLOSE状态而是进入TIME_WAIT状态是为了帮助服务端正常终止**
服务端需要确保它发送的FIN确实被客户端收到了，这需要用客户端发送的对FIN的ACK报文来进行确认，然而这个最后的ACK是可能丢失的，如果最后一个ACK丢失了而客户端又已经终止了，那么服务端就没有办法正常终止了。

现在客户端会在TIME_WAIT状态等待**2MSL时间**，这样如果最后一个ACK丢失了，服务端可以重发FIN，客户端可以继续响应ACK给服务端，直到服务端最终能收到last ack并且正常终止

>**MSL**:
> `MSL` 是 Maximum Segment Lifetime，**报文最大生存时间**.他是任何报文在网络上存在的最长的时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

>MSL 与 TTL 的区别：
> MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。**TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了**。

为什么是2MSL而不是1MSL，合理的解释是：
网络中可能有来自发送方的数据包，发送方发给接收方，接收方处理后又进行响应，所以一来一回需要两倍的等待时间。

2. **防止历史连接中的数据，被后面相同四元组指示的新的连接错误地接收**
在网络通畅的情况下，最后客户端发送给服务端的ack会被正常的接收，服务端可以正常地终止。但客户端仍然会维持2MSL的TIME_WAIT状态，客户端的套接字对应的FD一直被占用。
此时TIME_WAIT的主要作用是确保该TCP连接以前由于网络延迟被阻塞而未被接收的**旧数据**消亡在网络中，不会恰巧被后面相同四元组指示的新的连接错误地接收