# 连接前言
HTTP/2在TLS握手成功后，必须发送一个**连接前言（connectin preface）**，用来确认建立HTTP/2连接。

这个“连接前言”是标准的HTTP/1请求报文，使用纯文本的ASCII码格式，请求方法是*特别注册的一个关键字“PRI”*，全文只有24个字节：
```
PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n
```

只要服务器收到这个连接前言，就知道客户端在TLS上想用的是HTTP/2协议

# 头部压缩
因为语义上它与HTTP/1兼容，所以报文还是由“Header+Body”构成的，但在请求发送前，必须要用“**HPACK**”算法来压缩头部数据。

“HPACK”算法是专门为压缩HTTP头部定制的算法，是字典编码的一种算法。与gzip、zlib等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器*各自维护一份“索引表”*，也可以说是“字典”（这有点类似brotli），压缩和解压缩就是*查表和更新表*的操作

为了方便管理和压缩，HTTP/2废除了HTTP/1里的请求行。把请求行里的请求方法、URI、状态码等统一转换成头字段的形式。

并且给这些“不是头字段的头字段”起了个特别的名字——“**伪头字段**”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。

为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。

现在HTTP报文头就简单了，*全都是“Key-Value”形式的字段*，于是HTTP/2就为一些*最常用的头字段*定义了一个只读的“**静态表**”（Static Table）。如下图所示：
![[Pasted image 20220630161859.png]]

但如果表里只有Key没有Value，或者是自定义字段根本找不到该怎么办呢？

这就要用到“**动态表**”（Dynamic Table），它添加在静态表后面，结构相同，但会在编码解码的时候随时更新。

表建立好之后，后续发送HTTP报文时只需要一个字节发送对应字段的**索引号indx**就可以了，不用重复发送字段

随着在HTTP/2连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比gzip要好得多。

# 二进制帧
头部压缩之后，HTTP/2就要把报文压缩成二进制帧来发送出去。二进制格式保证了不会有歧义，使用位运算能够非常简单方便地解析

HTTP/2二进制帧的格式如下：
类似于TCP里的Segment，但是Frame Header比较小，只需要9字节
![[Pasted image 20220630162554.png]]
1. 帧开头是三个字节的帧长度字段（不包括头的9个字节）默认上限是2^14，最大是2^24，也就是说HTTP/2的帧通常不超过16K，最大是16M
2. 长度后面的一个字节是**帧类型**，大致可以分成**数据帧**和**控制帧**两类，HEADERS帧和DATA帧属于数据帧，存放的是HTTP报文，而SETTINGS、PING、PRIORITY等则是用来管理流的控制帧。
	HTTP/2总共定义了10种类型的帧，但一个字节可以表示最多256种，所以也允许在标准之外定义其他类型实现功能扩展
3. 再后面是**标志位**：可以保存8个标志位，携带简单的控制信息。常用的标志位有**END_HEADERS**表示头数据结束，相当于HTTP/1里头后的空行（“\r\n”），**END_STREAM**表示单方向数据发送结束（即EOS，End of Stream），相当于HTTP/1里Chunked分块结束标志（“0\r\n\r\n”）。
4. 最后四个字节是**流标识符**，也就是这个帧所属的流，接收方可以根据这个标识符把帧匹配到对应的流上，从*乱序的帧里面选出流ID相同的帧并重新按照发送顺序组装起来*
	流标识符虽然有4个字节，但最高位被保留不用，所以只有31位可以使用，也就是说，流标识符的上限是2^31，大约是21亿。

# 流与多路复用
**流是二进制帧的双向传输序列**

在HTTP/2连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。接收方将收到的帧按照编号排序重组即可恢复成发送时的报文

## HTTP/2流的特点
1. 流是可并发的，一个HTTP/2连接上可以同时发出多个流传输数据，实现”多路复用“
2. 客户端和服务器都可以创建流，双方互不干扰
3. 流是双向的，一个流内客户端和服务端都可以发送和接收数据帧
4. 流之间没有关系，是相互独立的；但是流内部的帧之间是严格按照顺序的
5. 流可以设置优先级，让服务器优先处理。例如先传HTML/CSS，后传图片，优化用户体验
6. 流ID不能重用，只能顺序递增，客户端发起的流ID是奇数；服务端发起的流ID是偶数。
7. 在流上发送”RST_STREAM“帧可以随时终止流，取消接收或者发送
8. 第0号流比较特殊，不能关闭，也不能发送数据帧，只能发送控制帧，用于流量控制

根据以上这些特点可以推出：
1. HTTP/2默认是长连接。因为在一个连接上使用多个流收发数据，那么它本身默认就是长连接
2. 下载大文件的时候想取消接收，在HTTP/1里只能断开TCP连接重新“三次握手”，成本很高，而在HTTP/2里就可以简单地发送一个“RST_STREAM”中断流，而长连接会继续保持。
3. 客户端和服务器两端都可以创建流，而流ID有*奇数偶数和上限的区分*，所以大多数的流ID都会是奇数，而且客户端在一个连接里最多只能发出2^30，也就是10亿个请求。
4. ID用完了就会发一个控制帧“GOAWAY”，真正关闭TCP连接。

# 流状态转换
![[Pasted image 20220630174027.png]]


## 小结

HTTP/2的内容实在是太多了，为了方便学习，我砍掉了一些特性，比如流的优先级、依赖关系、流量控制等。

但只要你掌握了今天的这些内容，以后再看RFC文档都不会有难度了。

1.  HTTP/2必须先发送一个“连接前言”字符串，然后才能建立正式连接；
    
2.  HTTP/2废除了起始行，统一使用头字段，在两端维护字段“Key-Value”的索引表，使用“HPACK”算法压缩头部；
    
3.  HTTP/2把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；
    
4.  流是HTTP/2虚拟的概念，是帧的双向传输序列，相当于HTTP/1里的一次“请求-应答”；
    
5.  在一个HTTP/2连接上可以并发多个流，也就是多个“请求-响应”报文，这就是“多路复用”。