如何在有限的带宽下高效快捷地传输大文件

# 数据压缩
通常浏览器在发送请求时都会带着“**Accept-Encoding**”头字段，里面是浏览器支持的压缩格式列表，例如gzip、deflate、br等，这样服务器就可以从中选择一种压缩算法，放进“**Content-Encoding**”响应头里，再把原数据压缩后发给浏览器

只对文本有较好的压缩效果，对于视频图片等已经高度压缩的数据效果不好。

# 分块传输
有时候并不是必须把一个大文件完整传输过来并存在内存后才能进行后续处理，例如服务端发过来一个视频流，浏览器可以边解析边播放。因此可以将大文件拆成小块来传输。

这种“**化整为零**”的思路在HTTP协议里就是“**chunked**”分块传输编码，在响应报文里用头字段“**Transfer-Encoding: chunked**”来表示，意思是报文里的body部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下body数据的长度是未知的，无法在头字段“**Content-Length**”里给出确切的长度，所以也只能用chunked方式分块发送


## 分块传输的编码规则
1.  每个分块包含两个部分，长度头和数据块；
2.  长度头是以CRLF（回车换行，即\r\n）结尾的一行明文，用16进制数字表示长度；
3.  数据块紧跟在长度头后，最后也用CRLF结尾，但数据不包含CRLF；
4.  最后用一个长度为0的块表示结束，即“0\\r\\n\\r\\n”。
![[Pasted image 20220618164702.png]]


浏览器在接受到分块数据之后自动按照编码规则去掉分块编码，重新组装出原始报文内容

# 范围请求
有时想要获取一个大文件中*某个片段的数据*（例如观看视频时想要快进，拖到某一个进度条处进行播放）

HTTP协议为了满足这样的需求，提出了“**范围请求**”（range requests）的概念，允许客户端在请求头里使用专用字段来*表示只获取文件的一部分*，相当于是**客户端的“化整为零”**。

范围请求不是Web服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”。

请求头**Range**是HTTP范围请求的专用字段，格式是“**bytes=x-y**”，其中的x和y是以字节为单位的数据范围。

**服务器收到Range字段后，需要做四件事：**
- 第一，它必须检查范围是否合法，比如文件只有100个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码**416**，意思是“你的范围请求有误，我无法处理，请再检查一下”。

- 第二，如果范围正确，服务器就可以根据Range头计算偏移量，读取文件的片段了，返回状态码“**206 Partial Content**”，和200的意思差不多，但表示body只是原数据的一部分。

- 第三，服务器要添加一个响应头字段**Content-Range**，告诉片段的实际偏移量和资源的总大小，格式是“**bytes x-y/length**”，与Range头区别在没有“=”，范围后多了总长度。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。

- 最后剩下的就是发送数据了，直接把片段用TCP发给客户端，一个范围请求就算是处理完了。

常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：
*   先发个HEAD，看服务器是否支持范围请求，同时获取文件的大小；
*   开N个线程，每个线程使用Range字段划分出各自负责下载的片段，发请求传输数据；
*   下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用Range请求剩下的那一部分就可以了。

# 多段数据
刚才说的范围请求一次只获取一个片段，其实它还支持在Range头里使用多个“x-y”，一次性获取多个片段数据。

这种情况需要使用一种特殊的MIME类型：“**multipart/byteranges**”，表示报文的body是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记。

每一个分段必须以boundary开始，之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围。
![[Pasted image 20220620112711.png]]
