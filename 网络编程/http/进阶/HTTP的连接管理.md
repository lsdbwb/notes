
# 短连接
HTTP协议（0.9/1.0）最初非常简单，通信方式采用简单的请求-应答模式。

底层数据传输基于TCP/IP协议，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。

因为客户端与服务器的整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“**短连接**”（short-lived connections）。早期的HTTP协议也被称为是“**无连接**”的协议。

# 长连接
针对短连接暴露出的缺点，HTTP协议就提出了“**长连接**”的通信方式，也叫“持久连接”（persistent connections）、“连接保活”（keep alive）、“连接复用”（connection reuse）。

收到响应报文后不会立即关闭TCP连接，而是保持连接状态

HTTP/1.1中的连接都会默认启用长连接

客户端可以在请求头里明确地要求使用长连接机制，使用的字段是**Connection**，值是“**keep-alive**”
服务器会发送“Connection: keep-alive”字段表示启用了长连接

长连接如果长时间不关闭，服务器必须在内存中保存连接的状态，时间长了会浪费服务端的资源，因此需要有关闭”长连接“的机制。
客户端和服务端都可以主动关闭HTTP连接：
- 客户端:在请求头加上*Connection：close*字段，告诉服务器：”这次通信后就关闭连接“。服务器看到这个字段，就知道客户端要主动关闭连接，于是在响应报文里也加上这个字段，发送之后就调用Socket API关闭TCP连接
- 服务端：服务端通常不会主动去关闭连接，可以使用一些策略（超时或者已发送报文条数）来管理连接
	拿Nginx来举例，它有两种方式：
	1.  使用“keepalive_timeout”指令，设置长连接的*超时时间*，如果在一段时间内连接上没有任何数据收发就主动断开连接，避免空闲连接占用系统资源。
	2.  使用“keepalive_requests”指令，设置*长连接上可发送的最大请求次数*。比如设置成1000，那么当Nginx在这个连接上处理了1000个请求后，也会主动断开连接。

# 队头阻塞问题
如下所示，客户端发来多个请求，由于队首的请求处理的太慢，导致后续请求也不得不跟着阻塞
![[Pasted image 20220620143950.png]]

队头阻塞是由于HTTP协议基本的”请求-应答“模型所导致的。因为HTTP规定报文必须是“一发一收”，这就形成了一个*先进先出的“串行”队列*。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。

**优化性能**
因为HTTP/1.1请求应答模型不能改变，所以队头阻塞问题在HTTP/1.1里面只能缓解。
- 使用*并发连接*：对同一个域名发起多个长连接，用数量解决质量问题
	每个客户端都建立多个连接的话服务端的资源扛不住
	HTTP协议建议客户端使用并发，但不能“滥用”并发，限制每个客户端并发的数量
- 域名分片：HTTP协议和浏览器不是限制并发连接数量吗？好，那我就多开几个域名，比如shard1.chrono.com、shard2.chrono.com，而这些域名都指向同一台服务器www.chrono.com，这样实际长连接的数量就又上去了