# 响应状态码
状态码是响应报文头状态行的一部分
![[Pasted image 20220608161407.png]]

表示状态而不是单纯地表示错误，表示HTTP数据处理的状态，客户端可以依据状态码适时转换处理状态，例如继续发送请求，转换协议，重定向跳转等

在HTTP协议中，正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。

客户端作为请求的发起方，获取响应报文后，需要**通过状态码**知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。

服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，**选择最恰当的状态码回复客户端**，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返400、500这样意思含糊不清的状态码。

目前RFC标准里总共有41个状态码，**但状态码的定义是开放的，允许自行扩展**。所以Apache、Nginx等Web服务器都定义了一些专有的状态码。如果你自己开发Web应用，也完全可以在不冲突的前提下定义新的代码。

RFC协议里状态码是三位数表示，分为5类

# 状态码分类
-   1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
    
-   2××：成功，报文已经收到并被正确处理；
    
-   3××：重定向，资源位置发生变动，需要客户端重新发送请求；
    
-   4××：客户端错误，请求报文有误，服务器无法处理；
    
-   5××：服务器错误，服务器在处理请求时内部发生了错误。

# 1xx
1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。

我们偶尔能够见到的是“**101 Switching Protocols**”。它的意思是客户端使用Upgrade头字段，要求在HTTP协议的基础上改成其他的协议继续通信，比如WebSocket。而如果服务器也同意变更协议，就会发送状态码101，但这之后的数据传输就不会再使用HTTP了。

# 2xx
2××类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。

“**200 OK**”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非HEAD请求，通常在响应头后都会有body数据。

“**204 No Content**”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有body数据。所以对于Web服务器来说，正确地区分200和204是很必要的。

“**206 Partial Content**”是HTTP分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与200一样，也是服务器成功处理了请求，但body里的数据不是资源的全部，而是其中的一部分。

状态码206通常还会伴随着头字段“**Content-Range**”，表示响应报文里body数据的具体范围，供客户端确认，例如“Content-Range: bytes 0-99/2000”，意思是此次获取的是总计2000个字节的前100个字节。

# 3xx
3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的URI重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的301、302跳转。

“**301 Moved Permanently**”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的URI再次访问。

与它类似的是“**302 Found**”，曾经的描述短语是“**Moved Temporarily**”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个URI来访问。

301和302都会在响应头里使用字段**Location**指明后续要跳转的URI，最终的效果很相似，浏览器都会重定向到新的URI。两者的根本区别在于语义，一个是“永久”，一个是“临时”，所以在场景、用法上差距很大。

比如，你的网站升级到了HTTPS，原来的HTTP不打算用了，这就是“永久”的，所以要配置301跳转，把所有的HTTP流量都切换到HTTPS。

再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于“临时”的，可以配置成302跳转，把流量临时切换到一个静态通知页面，浏览器看到这个302就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。

“**304 Not Modified**” 是一个比较有意思的状态码，它用于If-Modified-Since等条件请求，表示**资源未修改，用于缓存控制**。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

# 4xx
4××类状态码表示*客户端*发送的**请求报文有误**，服务器无法处理，它就是真正的“错误码”含义了。

“**400 Bad Request**”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是URI超长它没有明确说，只是一个**笼统的**错误，客户端看到400只会是“一头雾水”“不知所措”。所以，在开发Web应用时应当尽量避免给客户端返回400，而是要用其他更有明确含义的状态码。

“**403 Forbidden**”实际上不是客户端的请求出错，而是**表示服务器禁止访问资源**。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在body里详细说明拒绝请求的原因，不过现实中通常都是直接给一个“闭门羹”。

“**404 Not Found**”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是**资源在本服务器上未找到**，所以无法提供给客户端。但现在已经被“用滥了”，只要服务器“不高兴”就可以给出个404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比403还要令人讨厌。

4××里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：

-   405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许POST只能GET；
    
-   406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；
    
-   408 Request Timeout：请求超时，服务器等待了过长的时间；
    
-   409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；
    
-   413 Request Entity Too Large：请求报文里的body太大；
    
-   414 Request-URI Too Long：请求行里的URI太大；
    
-   429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；
    
-   431 Request Header Fields Too Large：请求头某个字段或总体太大；

# 5xx
5××类状态码表示客户端请求报文正确，但**服务器在处理时内部发生了错误**，无法返回应有的响应数据，是服务器端的“错误码”。

“**500 Internal Server Error**”与400类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。

“**501 Not Implemented**”表示客户端请求的功能还不支持，这个错误码比500要“温和”一些，和“即将开业，敬请期待”的意思差不多，不过具体什么时候“开业”就不好说了。

“**502 Bad Gateway**”通常是服务器作为**网关或者代理时**返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。

“**503 Service Unavailable**”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码503。

503是一个“临时”的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以503响应报文里通常还会有一个“**Retry-After**”字段，指示客户端可以在多久以后再次尝试发送请求。