# 概述
网络IO是指将网络传输过来的数据读到用户自定义的内存缓冲区的过程

## 网络IO的流程
- 网络IO涉及到两个缓冲区:用户缓冲区和内核缓冲区
因此网络IO分为两阶段
- **第一阶段 :** 数据从网络中传输过来后,首先会存放在内核缓冲区
- **第二阶段:** 用户在调用read时,从内核缓冲区中拷贝数据到用户缓冲区

 同样,用户在write时,先将数据从用户缓冲区拷贝到内核缓冲区,然后再通过网络传输

![[Pasted image 20220528163823.png]]


# 五种网络IO模型
根据进行网络IO时两个阶段情况的不同,划分为5种网络IO模型

### 阻塞IO(blocking IO)
- 所有的套接字默认都是阻塞的,调用read时如果内核缓冲区没有就绪的数据,则会陷入等待,直到数据就绪再将数据拷贝到用户缓冲区,然后read函数返回
![[Pasted image 20220528171008.png]]
- 陷入阻塞时,应用进程什么也做不了
#### 阻塞IO的流程
![[Pasted image 20220529101314.png]]
每个socket都有自己的内核输入输出缓冲区以及等待队列
1. 数据从网络中传输到本地网卡时,通过DMA将数据写入网卡的内存的缓冲区
2. 网卡产生硬件中断,CPU根据中断向量表找到网卡中断处理程序,然后执行该中断处理程序
3. 中断处理程序根据报文数据的端口,将网卡缓冲区的数据拷贝到对应套接字的输入缓冲区中
4. 根据socket的等待队列唤醒等待在上面的进程A,将进程A加入工作队列,进程A重新变为就绪态,等待操作系统调度

### 非阻塞IO(non-blocking IO)
- 将套接字设置为non-blocking后,调用read时如果内核缓冲区没有就绪的数据,不会陷入等待,而是直接返回EWOULDBLOCK错误.
- 因此应用进程需要反复调用read函数,直到内核缓冲区有数据后,调用read时才能读到数据
![[Pasted image 20220528171425.png]]
- 非阻塞IO不会陷入内核态阻塞,但是如果想读到数据,应用程序就必须反复调用read(不知道数据什么时候就绪),因此cpu相当于在空转

### IO多路复用(IO multiplexing)
- 因为网络中同时不止有一个连接,如果使用阻塞式IO模型,在多连接的情况下,只能开多个线程来处理,一个线程处理一个连接.(并发能力和线程数量相关)
- 因此提出IO多路复用模型,原来一次只监听内核中的一个套接字,现在设计一个机制来一次性监听内核中的多个套接字.
- 使用IO多路复用,只需要一个线程阻塞就行了,负责监听的线程监听多个套接字,每次从内核态返回时告知哪几个套接字就绪了,应用进程再去依次处理
![[Pasted image 20220528174640.png]]
- linux有三种IO多路复用函数(select,poll, epoll)[[IO多路复用]]

### 信号驱动IO(signal drive IO)
- 因为应用程序不会知道网络中传输的数据什么时候到达内核缓冲区,因此上面三种方式要么阻塞住,要么轮询.(IO多路复用时指定一个线程阻塞)
- 上面三种IO模型都缺少一种内核态到用户态的通知机制,即内核缓冲区有数据到来时,我能通知应用程序去取
- 因此想到了信号作为通知机制
- 应用程序在read前先注册好信号回调函数,read时如果内核缓冲区没有数据则不会陷入阻塞,应用进程可以去做其他的事情.当内核缓冲区有数据后,通过信号告诉应用进程,应用进程进入信号处理函数拷贝数据到用户缓冲区

![[Pasted image 20220528172357.png]]
- 优点:应用程序完全不用阻塞
- 缺点:TCP连接的断开/读/写事件都会触发信号,但是信号无法较好地区分这些事件

### 异步IO(asynchronous IO)
- 信号驱动IO提供了通知机制,但是只是通知应用程序内核缓冲区的数据准备好了,将内核缓冲区的数据拷贝到应用缓冲区这一步骤还是应用程序自己来做的.
- 异步IO不仅提供了通知机制,而且会帮应用程序把数据从内核缓冲区拷贝到应用缓冲区
- 当内核通知应用程序时,数据已经完全准备好了
![[Pasted image 20220529094828.png]]

总结:
从阻塞IO到异步IO,IO模型的演进主要还是希望在进行IO时不要浪费CPU.最终异步IO的思想和中断的思想很相似,即使用通知机制
![[Pasted image 20220529094921.png]]
