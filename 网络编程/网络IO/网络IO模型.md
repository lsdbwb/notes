# 概述
网络IO是指将网络传输过来的数据读到用户自定义的内存缓冲区的过程

## 网络IO的流程
- 网络IO涉及到两个缓冲区:用户缓冲区和内核缓冲区
因此网络IO分为两阶段
- **第一阶段 :** 数据从网络中传输过来后,首先会存放在内核缓冲区
- **第二阶段:** 用户在调用read时,从内核缓冲区中拷贝数据到用户缓冲区

 同样,用户在write时,先将数据从用户缓冲区拷贝到内核缓冲区,然后再通过网络传输

![[Pasted image 20220528163823.png]]

# 五种网络IO模型
根据进行网络IO时两个阶段情况的不同,划分为5种网络IO模型

### 阻塞IO(blocking IO)
- 所有的套接字默认都是阻塞的,调用read时如果内核缓冲区没有就绪的数据,则会陷入等待,直到数据就绪再将数据拷贝到用户缓冲区,然后read函数返回
![[Pasted image 20220528171008.png]]
- 陷入阻塞时,应用进程什么也做不了

### 非阻塞IO
- 将套接字设置为non-blocking后,调用read时如果内核缓冲区没有就绪的数据,不会陷入等待,而是直接返回EWOULDBLOCK错误.
- 因此应用进程需要反复调用read函数,直到内核缓冲区有数据后,调用read时才能读到数据
![[Pasted image 20220528171425.png]]
- 非阻塞IO不会陷入内核态阻塞,但是如果想读到数据,应用程序就必须反复调用read(不知道数据什么时候就绪),因此cpu相当于在空转

### IO多路复用
- 因为网络中同时不止有一个连接,如果使用阻塞式IO模型,在多连接的情况下,只能开多个线程来处理,一个线程处理一个连接.(并发能力和线程数量相关)
- 因此提出IO多路复用模型,原来一次只监听内核中的一个套接字,现在设计一个机制来一次性监听内核中的多个套接字.
- 使用IO多路复用,只需要一个线程阻塞就行了,负责监听的线程监听多个套接字,每次从内核态返回时告知哪几个套接字就绪了,应用进程再去依次处理
![[Pasted image 20220528174640.png]]
- linux有三种IO多路复用函数(select,poll, epoll)[[IO多路复用机制]]

### 信号驱动IO
- 因为应用程序不会知道网络中传输的数据什么时候到达内核缓冲区,因此上面三种方式要么阻塞住,要么轮询.(IO多路复用时指定一个线程阻塞)
- 上面三种IO模型都缺少一种内核态到用户态的通知机制,即内核缓冲区有数据到来时,我能通知应用程序去取
- 因此想到了信号作为通知机制
- 应用程序在read前先注册好信号回调函数,read时如果内核缓冲区没有数据则不会陷入阻塞,应用进程可以去做其他的事情.当内核缓冲区有数据后,通过信号告诉应用进程,应用进程进入信号处理函数拷贝数据到用户缓冲区

![[Pasted image 20220528172357.png]]
- 应用程序完全不用阻塞

### 异步IO
