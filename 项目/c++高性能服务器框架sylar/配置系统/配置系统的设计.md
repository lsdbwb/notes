# 整体结构
![[Pasted image 20220504110419.png]]
## 内存中的配置系统
- 一个配置项即为一个ConfigVar，ConfigVar有三个成员:
	1. m_name : 配置项的名称
	2. m_description : 配置项的描述
	3. m_var ：具体的配置项的值（值的类型是不确定的,所以使用模板类型T来表示）
- 所有的配置项由Config类负责管理，配置存放在Config类的s_datas中。s_datas是一个map,key为配置项的名称,value为ConfigVar的智能指针
	` typedef std::map<std::string, ConfigVarBase::ptr> ConfigVarMap;`
	Config类的成员和方法都是static的，这是因为整个服务器框架只需要一个全局的Config
## 配置文件
- 使用的配置文件的格式为YAML
- 使用YAML-CPP库来做YAML配置文件的序列化和反序列化
- YAML配置文件中的每一个配置项对应内存中的一个YAML::node节点
- 我们的内存配置系统使用LoadFromYaml（YAML::node）从根节点开始遍历，处理每一个配置项并加入到保存所有配置的map s_datas中

# 设计思想
**约定大于配置**
- 一个系统的参数是非常多的（如果将这么多参数都用配置文件来存，配置文件会变得特别臃肿），但是其中大部分参数都使用默认值即可，通常情况下不会改变，将那些经常需要改变的配置项放在配置文件中即可。
- 即系统应该假定合理的默认值，不应该要求提供不必要的配置
- 约定大于配置的思想如何体现在上述配置系统中
	1. Config类中的所有配置项都有一个预先设定的默认值。（配置的类型，值已经规定好了）
	2. YAML配置文件中的所有配置项是需要经常改变的，里面的配置项内存中已经存在，加载YAML文件只是会修改内存中配置项的值。
	3. 没有YAML配置文件，系统也能按照默认值运行
	